0001   0000             ; SYSINFO81 
0002   0000             ; 	GPL
0003   0000             ; 	Oliver Lange
0004   0000             ; 	Version 1.0.1
0005   0000             
0006   0000             ; Compile with "tasm -80 -b wspdrv.asm wspdrv.p" 
0007   0000             
0008   0000             
0009   0000             ; driver for wespi
0010   0000             ;
0011   0000             
0012   0000             
0013   0000              
0014   0000             #define db .byte ;  cross-assembler definitions 
0015   0000             #define dw .word 
0016   0000             #define ds .block 
0017   0000             #define org .org 
0018   0000             #define end .end 
0019   0000             
0020   0000             
0021   0000             
0022   0000             #define ADDR_DISABLE 0
0023   0000             #define UPDATE	01FCh	; LOAD/SAVE adress update subroutine in ROM
0024   0000             
0025   0000             ;;#define VERBOSE 1
0026   0000              
0027   4009             org     $4009 ; BASIC PROGRAMM
0028   4009             ;= System variables ============================================ 
0029   4009              
0030   4009 00             db 0     	;VERSN 
0031   400A 00 00          dw 0     	;E_PPC 
0032   400C 3E 43          dw dfile      ;D_FILE 
0033   400E 3F 43          dw dfile+1    ;DF_CC 
0034   4010 59 43          dw var   	;VARS 
0035   4012 00 00          dw 0     	;DEST 
0036   4014 5A 43          dw var+1      ;E_LINE 
0037   4016 59 43          dw last-1     ;c_ADD 
0038   4018 00 00          dw 0     	;X_PTR 
0039   401A 5A 43          dw last  	;STKBOT 
0040   401C 5A 43          dw last  	;STKEND 
0041   401E 00             db 0     	;BERG 
0042   401F 5D 40          dw membot     ;MEM 
0043   4021 00             db 0     ;not used 
0044   4022 02             db 2     ;DF_SZ 
0045   4023 01 00          dw 1     ;S_TOP 
0046   4025 FF FF FF       db $FF,$FF,$FF     ;LAST_K 
0047   4028 37             db 55    ;MARGIN 
0048   4029 23 43          dw line10     ;NXTLIN   line10   dfile
0049   402B 00 00          dw 0     ;OLDPPC 
0050   402D 00             db 0     ;FLAGX 
0051   402E 00 00          dw 0     ;STRLEN 
0052   4030 8D 0C          dw $0C8D      ;T_ADDR 
0053   4032 00 00          dw 0     ;SEED 
0054   4034 FF FF          dw $FFFF      ;FRAMES 
0055   4036 00 00          db 0,0   ;COORDS 
0056   4038 BC             db $BC   ;PR_CC 
0057   4039 21 18          db 33,24      ;S_POSN 
0058   403B 40             db 01000000B  ;CDFLAG 
0059   403C                ds 33    ;Print buffer --- now used for loader code, all loaded programs need to have the same !
0060   405D             
0061   405D             membot: 
0062   405D                ds 30    ;Calculator�s memory area 
0063   407B                ds 2     ;not used 
0064   407D              
0065   407D             ;= First BASIC line, asm code ================================== 
0066   407D              
0067   407D             line0: 
0068   407D 00 00          db 0,0   ;line number 
0069   407F A2 02          dw line10-$-2 ;line length 
0070   4081 EA             db $ea   ; REM 
0071   4082             
0072   4082             
0073   4082             #define ELINE	4014h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0074   4082             #define ELINEHI	4015h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0075   4082             
0076   4082             #define SHOW	0207h  ; ROM-Routinen
0077   4082             #define FAST	02E7h
0078   4082             #define RCLS	0A2Ah
0079   4082             #define GETKEY	02BBh
0080   4082             
0081   4082             
0082   4082             #DEFINE RST_PRTCHAR RST 10H
0083   4082             #DEFINE c_SPACE 0
0084   4082             #DEFINE c_NEWLINE 76H
0085   4082             #DEFINE c_0 1CH
0086   4082             
0087   4082             #DEFINE c_A 26H
0088   4082             #DEFINE c_B c_A+1
0089   4082             #DEFINE c_C c_A+2
0090   4082             #DEFINE c_D c_A+3
0091   4082             #DEFINE c_E c_A+4
0092   4082             #DEFINE c_F c_A+5
0093   4082             #DEFINE c_G c_A+6
0094   4082             #DEFINE c_H c_A+7
0095   4082             #DEFINE c_I c_A+8
0096   4082             #DEFINE c_J c_A+9
0097   4082             #DEFINE c_K c_J+1
0098   4082             #DEFINE c_L c_J+2
0099   4082             #DEFINE c_M c_J+3
0100   4082             #DEFINE c_N c_J+4
0101   4082             #DEFINE c_O c_J+5
0102   4082             #DEFINE c_P c_J+6
0103   4082             #DEFINE c_Q c_J+7
0104   4082             #DEFINE c_R c_J+8
0105   4082             #DEFINE c_S c_J+9
0106   4082             #DEFINE c_T c_S+1
0107   4082             #DEFINE c_U c_S+2
0108   4082             #DEFINE c_V c_S+3
0109   4082             #DEFINE c_W c_S+4
0110   4082             #DEFINE c_X c_S+5
0111   4082             #DEFINE c_Y c_S+6
0112   4082             #DEFINE c_Z c_S+7
0113   4082             
0114   4082             #define UFM_ERRNO 16434 ; Definiert in UFM, Fehlercode 1 Byte (eigentlich SEED)
0115   4082             #define UFM_CMDBUF 16444 ; Definiert in UFM, 32 Byte, alternative Kommando�bergabe (eigentlich PRBUF)
0116   4082             #define UFM_COORDS 16438 ; L�ngen�bergabe 2 Byte (eigentlich COORDS)
0117   4082             
0118   4082             
0119   4082             ;
0120   4082             ;   === Main entry point ====
0121   4082             ;
0122   4082             
0123   4082             BASIC_START:
0124   4082 CD 5B 42    	CALL NAME	; get command line arg
0125   4085 18 1B       	JR BASIC_CONT
0126   4087 00          	NOP
0127   4088 00          	NOP
0128   4089 00          	NOP
0129   408A             
0130   408A             CALL_START:	; (IN UFM als START_ADDR+6 festgelegt)
0131   408A 21 3C 40    	LD HL,UFM_CMDBUF
0132   408D E5              PUSH HL
0133   408E                 ;  get length in BC by parsing for '"' or so..
0134   408E 01 00 00        LD   BC,0
0135   4091             ENDPRSLP:
0136   4091 7E              LD   A,(HL)
0137   4092 FE 0B           CP   11     ; is " ?
0138   4094 28 04           JR   Z, EXITPRSLP
0139   4096 03              INC  BC
0140   4097 23              INC  HL
0141   4098 18 F7           JR   ENDPRSLP
0142   409A             EXITPRSLP:
0143   409A E1              POP  HL ; original pointer
0144   409B CD B8 40    	CALL GENER_START
0145   409E 32 32 40    	LD (UFM_ERRNO),A
0146   40A1 C9          	RET
0147   40A2             
0148   40A2             BASIC_CONT:
0149   40A2 CD B8 40    	CALL GENER_START ; A is 0 for ok, !=0 for error
0150   40A5 A7          	AND A
0151   40A6 28 0F       	JR Z,BAS_OK
0152   40A8 3E 2A       	LD A,c_E		; Ausgabe ERR
0153   40AA D7          	RST 10h 
0154   40AB 3E 37       	LD A,c_R
0155   40AD D7          	RST 10h
0156   40AE 3E 37           LD A,c_R
0157   40B0 D7          	RST 10h
0158   40B1 3E 76           LD A,c_NEWLINE
0159   40B3 D7          	RST 10h
0160   40B4                 ; exit
0161   40B4 AF              XOR A
0162   40B5 CF          	RST 08h
0163   40B6 09              db  09h             ; Error Report: Invalid argument
0164   40B7             	;db 0FFh
0165   40B7             
0166   40B7             BAS_OK:
0167   40B7 C9          	RET  ; TODO check if RET or better RST8 with -1
0168   40B8             ;    XOR A		; sonst zurueck nach BASIC
0169   40B8             ;	RST 08h
0170   40B8             ;	db 0FFh
0171   40B8             	
0172   40B8             
0173   40B8             GENER_START: ; Interpreting the string independent of its origin, on ret A=0 for okay, BC retval to basic
0174   40B8 7E          	LD A,(HL)   ; HL=start, BC=length
0175   40B9 23              INC  HL
0176   40BA 0B              DEC  BC
0177   40BB 11 D4 40        LD   DE,GENER_END
0178   40BE D5              PUSH DE     ; ret adddess
0179   40BF             ;	CP c_I		; Info
0180   40BF             ;	JP Z,INFO1
0181   40BF FE 38       	CP c_S		; Save
0182   40C1 CA 37 41    	JP Z,SAVE1
0183   40C4             ;	CP c_L		; Load
0184   40C4             ;	JP Z,LOAD1
0185   40C4             ;	CP 29h		; ist es ein D;
0186   40C4             ;	JP Z,DIR1
0187   40C4             ;	CP 3Bh		; ist es ein V (UFM)
0188   40C4             ;	JP Z,DIRV1
0189   40C4             ;	CP 30h		; ist es ein K (UFM)
0190   40C4             ;	JP Z,DIRK1
0191   40C4             ;	CP 37h		; ist es ein R
0192   40C4             ;	JP Z,RENAM1
0193   40C4             ;	CP 2Ah		; ist es ein E
0194   40C4             ;	JP Z,ERAS1
0195   40C4 FE 39       	CP c_T		; Test, return 0...1023 dependng on number of correct bytes
0196   40C6 CA 07 41    	JP Z,TESTPATTERN
0197   40C9 FE 2D       	CP c_H		; Help
0198   40CB CA C8 41    	JP Z,HLP
0199   40CE FE 0F       	CP 0Fh		; ist es ein ?
0200   40D0 CA C8 41    	JP Z,HLP
0201   40D3 C9              ret 
0202   40D4             
0203   40D4             GENER_END:
0204   40D4 F5              PUSH AF ; holds our error status
0205   40D5 C5              PUSH BC ; ret value...
0206   40D6 CD 07 02    	CALL SHOW
0207   40D9 C1              POP  BC
0208   40DA F1              POP  AF
0209   40DB C9          	RET
0210   40DC             	
0211   40DC             
0212   40DC             
0213   40DC             
0214   40DC             CHECKCOMMA:  ; Z is set when comma seperator found in string, NZ if not, uses A
0215   40DC                 ; BC =0?
0216   40DC AF              XOR  A
0217   40DD B9              CP   C
0218   40DE 20 05           JR   NZ,CHKK_CONT
0219   40E0 B8              CP   B
0220   40E1 20 02           JR   NZ,CHKK_CONT
0221   40E3 3C              INC  A ; clear the Z flag
0222   40E4 C9              RET     ; no match till end
0223   40E5             CHKK_CONT:
0224   40E5 7E              LD   A, (HL)
0225   40E6 FE 1A           CP   26     ; comma
0226   40E8 C8              RET  z
0227   40E9 FE 1A           CP   26     ; also check for semicolon
0228   40EB C8              RET  z
0229   40EC 23              INC  HL
0230   40ED 0B              DEC  BC
0231   40EE 18 EC           JR CHECKCOMMA
0232   40F0             
0233   40F0             
0234   40F0             SKIPEMPTY:  ; Z is set when comma seperator found in string, NZ if not, uses A
0235   40F0                 ; BC =0?
0236   40F0 AF              XOR  A
0237   40F1 B9              CP   C
0238   40F2 20 05           JR   NZ,CHKE_CONT
0239   40F4 B8              CP   B
0240   40F5 20 02           JR   NZ,CHKE_CONT
0241   40F7 3C              INC  A ; clear the Z flag
0242   40F8 C9              RET     ; no match till end
0243   40F9             CHKE_CONT:
0244   40F9 BE              CP   (HL)
0245   40FA C0              RET  NZ ; not empty,leave
0246   40FB 23              INC  HL
0247   40FC 0B              DEC  BC
0248   40FD 18 F1           JR SKIPEMPTY
0249   40FF             
0250   40FF             PRINTA:
0251   40FF E5              PUSH HL
0252   4100 D5              PUSH DE
0253   4101 C5              PUSH BC
0254   4102 D7              RST 10H
0255   4103 C1              POP  BC
0256   4104 D1              POP  DE
0257   4105 E1              POP  HL
0258   4106 C9              RET
0259   4107                 
0260   4107             
0261   4107             TESTPATTERN:
0262   4107             	; HL points to arg string, BC number of chars
0263   4107 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0264   4108 C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0265   4109                 ; Check if we have contact
0266   4109 3E 39           LD   A, c_T
0267   410B CD FF 40        CALL PRINTA
0268   410E                 
0269   410E CD F4 41        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0270   4111 A7              AND A
0271   4112                 ; Send SAVE request
0272   4112 C1              POP  BC
0273   4113 E1              POP  HL ; recover name pointer/length
0274   4114 28 1B           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0275   4116             
0276   4116 41              ld   B,C ; length, assume <256
0277   4117 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0278   4119 CD 6F 42        call SEND_PACKET
0279   411C             
0280   411C                 ; now retrieve 1024 bytes and see how many are correct
0281   411C                 ; gap between byte calls should be 77+12+7 - 17-10 = 69 clocks
0282   411C 01 00 00        LD   BC,0
0283   411F             TESTBLOOP:
0284   411F C5              PUSH BC
0285   4120 00              NOP         ; timing adjust
0286   4121 CD 41 42        CALL QLD_GETBYTE    ; uses BC D, result in A
0287   4124 C1              POP  BC
0288   4125 B9              CP   C  ; incomming data in A is 0,1,2,3,4...255,0,1... as byte
0289   4126 3E 00           LD   A,0 ; not affect flags, test never reports errors to better automatize
0290   4128 C0              RET  NZ ; report BC at point of first failure
0291   4129 03              INC  BC
0292   412A 3E 10           LD   A,16 ; 4kbyte testsize
0293   412C B8              CP   B
0294   412D 20 F0           JR   NZ, TESTBLOOP
0295   412F AF              XOR  A
0296   4130 C9              RET ; BC WILL be at maximum now
0297   4131             
0298   4131             
0299   4131             
0300   4131             ERREXIT:
0301   4131 3E 01           LD   A,1
0302   4133 01 00 00        LD   BC,0
0303   4136 C9              RET
0304   4137             
0305   4137             SAVE1:
0306   4137             	; HL points to arg string, BC number of chars
0307   4137 E5              PUSH HL  ; orig pos of args (w/o prefix S)
0308   4138 C5              PUSH BC  ; orig lenght of args (w/o prefix S)
0309   4139 CD DC 40        CALL CHECKCOMMA
0310   413C 28 4A           JR   Z, BINSAVE
0311   413E             
0312   413E                 ; Check if we have contact
0313   413E                     
0314   413E 3E 38           LD   A, c_S
0315   4140 CD FF 40        CALL PRINTA
0316   4143                 
0317   4143 CD F4 41        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0318   4146 A7              AND A
0319   4147                 ; Send SAVE request
0320   4147 C1              POP  BC
0321   4148 E1              POP  HL ; recover name pointer/length
0322   4149 28 E6           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0323   414B             
0324   414B CD F0 40        CALL SKIPEMPTY
0325   414E AF              XOR  A
0326   414F B9              CP   C
0327   4150 28 DF           JR   Z, ERREXIT ; NO NAME
0328   4152 41              ld   B,C ; length, assume <256
0329   4153 0E 5B           ld   C,91 ; packet ID ZX_QSAVE_TAG_SAVEPFILE
0330   4155 CD 6F 42        call SEND_PACKET
0331   4158             
0332   4158 11 09 40    	LD DE,4009h		; Get length
0333   415B 2A 14 40    	LD HL,(ELINE)	
0334   415E A7          	AND A		; clear carry
0335   415F ED 52       	SBC HL,DE	; HL=length
0336   4161 44          	LD B,H
0337   4162 4D          	LD C,L
0338   4163 EB          	EX DE,HL	; Now HL=Start, BC=length
0339   4164             SVSENDFUL:
0340   4164 AF              XOR  A
0341   4165 B8              CP   B
0342   4166 28 0C           JR   Z, SVSENDLAST
0343   4168                 ; send full packets
0344   4168 C5              PUSH BC
0345   4169 06 00           LD   B,0    ; 256 bytes
0346   416B 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0347   416D CD 6F 42        call SEND_PACKET
0348   4170 C1              POP  BC
0349   4171 05              DEC  B
0350   4172 18 F0           JR   SVSENDFUL
0351   4174             
0352   4174             SVSENDLAST:
0353   4174 AF              XOR  A
0354   4175 B9              CP   C
0355   4176 28 06           JR   Z, SVSENDEND
0356   4178 41              LD   B,C ; length
0357   4179 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0358   417B CD 6F 42        call SEND_PACKET
0359   417E             
0360   417E             SVSENDEND:
0361   417E CD 27 42        CALL QS_FINAL_ACK   ; Z set for success
0362   4181 20 AE           JR   NZ, ERREXIT
0363   4183 AF              XOR  A
0364   4184 01 01 00        LD   BC, 1
0365   4187 C9          	RET
0366   4188             
0367   4188             
0368   4188             
0369   4188             BINSAVE: ; TODO PARSE ADDR, send header and go on to SVSENDFUL
0370   4188             
0371   4188             
0372   4188             
0373   4188             HLPTXT:
0374   4188 3F 3D 00 3C 	db c_Z,c_X,0,c_W,c_E,c_S,c_P,c_I,0,c_D,c_R,c_I,c_V,c_E,c_R,0, c_0,27,c_0+1,c_0,c_0,c_NEWLINE
0374   418C 2A 38 35 2E 
0374   4190 00 29 37 2E 
0374   4194 3B 2A 37 00 
0374   4198 1C 1B 1D 1C 
0374   419C 1C 76 
0375   419E 76              db c_NEWLINE
0376   419F             ;	db "INFO  ",22h,"I",22h,0dh
0377   419F             ;	db "DIR   ",22h,"D",22h,0dh
0378   419F             ;	db "ERASE ",22h,"ENAME.P",22h,0dh
0379   419F             ;	db "MKDIR ",22h,"DMVERZ",22h,0dh
0380   419F             ;	db "RMDIR ",22h,"DEVERZ",22h,0dh
0381   419F             ;	db "CHDIR ",22h,"DCVERZ",22h,0dh
0382   419F             ;	db "LOAD  ",22h,"LNAME.P",22h,0dh
0383   419F             ;	db "BLOAD ",22h,"LNAME.B,SSSS",22h,0dh
0384   419F 38 26 3B 2A 	db c_S,c_A,c_V,c_E, 0 , 0 , 0, 11, c_S, c_N, c_A, c_M, c_E, 11   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0384   41A3 00 00 00 0B 
0384   41A7 38 33 26 32 
0384   41AB 2A 0B 
0385   41AD             ;	db "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0386   41AD             ;	db "RENAME",22h,"ROLDNAME NEWNAME",22h,0dh
0387   41AD 39 2A 38 39 	db c_T,c_E,c_S,c_T, 0 , 0 , 0, 11, c_T, c_L, c_T, c_T, c_T, c_0+2, 11   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0387   41B1 00 00 00 0B 
0387   41B5 39 31 39 39 
0387   41B9 39 1E 0B 
0388   41BC 2D 2A 31 35 	db c_H,c_E,c_L,c_P, 0 , 0 , 0, 11, c_H, 11   ;  c_H,   "HELP  ",22h,"H",22h,0dh
0388   41C0 00 00 00 0B 
0388   41C4 2D 0B 
0389   41C6             ;	db "FOR SIGGI'S UFM :V/R/K",0dh
0390   41C6 76              db c_NEWLINE
0391   41C7 FF          	db $ff
0392   41C8             
0393   41C8             
0394   41C8             ; === Subroutine print help text ====
0395   41C8             
0396   41C8 21 88 41    HLP:	LD HL,HLPTXT
0397   41CB 7E          HLP1:	LD A,(HL)
0398   41CC FE FF       	CP $FF
0399   41CE 28 04       	JR Z, EXITHLP
0400   41D0 D7              RST 10H
0401   41D1 23          	INC HL
0402   41D2 18 F7       	JR HLP1
0403   41D4             EXITHLP:
0404   41D4 01 2A 00        LD   BC,42
0405   41D7 AF              XOR  A
0406   41D8 C9              RET
0407   41D9             
0408   41D9             
0409   41D9             
0410   41D9             GO_QSAVE_MODE:
0411   41D9 CD E7 02    	CALL FAST	; go to fast mode
0412   41DC DB FE           IN      A,($FE)         ; signal to 0 pause    
0413   41DE 06 C8           LD B,200  ; 200=200ms Pause
0414   41E0 C5          W1: push BC
0415   41E1 06 00           ld b,0
0416   41E3             W2:
0417   41E3 10 FE           djnz W2     ; 1 millisec (256*4)
0418   41E5 C1              pop BC
0419   41E6 10 F8           djnz W1
0420   41E8 1E 4B           LD E, 75    ; ID for ZX_SAVE_TAG_QSAVE_START
0421   41EA CD 1F 03        call $031F  ; SAVE byte in E
0422   41ED D3 FF           OUT     ($FF),A         ; ; signal to 1 / syncoff, send hsyncs
0423   41EF 06 00           ld b,0
0424   41F1             W4:
0425   41F1 10 FE           djnz W4     ; 1 millisec (256*4) to go to QSAVE mode
0426   41F3 C9              RET
0427   41F4             
0428   41F4             TRY_HANDSHAKE:  ; See if WESPI responds, return 1 if so, 0 for timeout
0429   41F4 CD D9 41        CALL GO_QSAVE_MODE
0430   41F7 21 04 40        ld   hl, 16388 ; RAMTOP
0431   41FA 06 02           ld   B,2
0432   41FC 0E 5A           ld   C,90 ; packet ID ZX_QSAVE_TAG_HANDSHAKE
0433   41FE CD 6F 42        call SEND_PACKET
0434   4201 06 B5           ld   b,181  ; timeout, 500ms (inner loop 3.15ms)
0435   4203             HS_LOOP1:
0436   4203 C5              PUSH BC
0437   4204 06 00           LD   B,0
0438   4206             HS_LOOP2:                  ; 35 cycles=10.7us, inner Loop 2.75 millisec
0439   4206 DB FE           in a,($FE)  ; 11
0440   4208 17              rla         ; 4
0441   4209 38 0E           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0442   420B 10 F9           DJNZ HS_LOOP2 ;13
0443   420D                 ; re-check here to not have a blind spot for outer loop
0444   420D DB FE           in a,($FE)  ; 11
0445   420F 17              rla         ; 4
0446   4210 38 07           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0447   4212 C1              POP  BC
0448   4213 10 EE           DJNZ HS_LOOP1
0449   4215 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff
0450   4217                 ; no signal found
0451   4217 AF              XOR  A
0452   4218 C9              RET
0453   4219             
0454   4219             HS_FOUND
0455   4219 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff
0456   421B                 ; let the output recover with active signal after being low from input. takes about 1ms as seen in oscilloscope
0457   421B 06 00           LD   B,0
0458   421D             HS_FINALDELAY: ; 2ms here
0459   421D 7E              LD   A,(HL)
0460   421E 7E              LD   A,(HL)
0461   421F 10 FC           DJNZ HS_FINALDELAY
0462   4221 C1              POP  BC
0463   4222 3E 01           LD   A,1
0464   4224 A7              AND  A
0465   4225 C9              RET
0466   4226             
0467   4226             QS_FINAL_SZ:
0468   4226 00              db 0 ; size of return packet to request, use smallest possible
0469   4227             
0470   4227             QS_FINAL_ACK:  ; Get info is operation was sussessful (Z) or failed (NZ), USES BC DE HL, A
0471   4227 21 26 42        ld   hl, QS_FINAL_SZ ; Requested length
0472   422A 06 01           ld   B,1
0473   422C 0E 63           LD   C,99 ; packet ID ZX_QSAVE_TAG_END_RQ
0474   422E CD 6F 42        call SEND_PACKET
0475   4231             
0476   4231                 ; await reply, first byte is tag, then result
0477   4231 CD 41 42        CALL QLD_GETBYTE
0478   4234 FE 2A           CP   42 ; tag
0479   4236 C0              RET  NZ
0480   4237 06 08           ld B,8  ; 
0481   4239             QSFDLY:
0482   4239 10 0F           djnz lgapdly     ; 13*n-5 = 47 for 4
0483   423B CD 41 42        CALL QLD_GETBYTE
0484   423E FE 01           CP   1 ; result
0485   4240 C9              RET    ; Z on match
0486   4241             
0487   4241             
0488   4241             
0489   4241             ; gab between byte calls should be 77+12+7 - 17-10 = 69 clocks
0490   4241             
0491   4241             QLD_GETBYTE:    ; uses BC D, result in A
0492   4241 0E FE           ld c,$fe   ; 7
0493   4243 06 08           ld b,8  ; 7    for gap between start and bits
0494   4245             
0495   4245             lwt_stdly:                  ; 25 cycles=7.7us
0496   4245 DB FE           in a,($FE)  ; 11
0497   4247 17              rla         ; 4
0498   4248 30 FB           jr nc,lwt_stdly ; 12 / 7  (D7=0 is low level, wait for high)
0499   424A                 ; trigger is seen 4us too late in average, so wait 48-4 - 4 us now: 130 cy in-in
0500   424A             lgapdly:
0501   424A 10 FE           djnz lgapdly     ; 13*n-5 = 99 for 8
0502   424C 06 08           ld b,8  ; 7
0503   424E             lbloop:                 ;  need 104 for 32us
0504   424E ED 50           in d,(c)    ; 12
0505   4250 CB 12           rl d        ; 8
0506   4252 17              rla         ; 4 (rl a is 8)
0507   4253 16 04           ld d,4      ; 7
0508   4255             lbdly:
0509   4255 15              dec d          ; 4          b*16-5 = 59
0510   4256 20 FD           jr nz,lbdly     ; 12 / 7
0511   4258 10 F4           djnz lbloop     ; 13 / 8
0512   425A C9              RET     
0513   425B                 
0514   425B                 ;ORIGINAL:
0515   425B                 ;ld (hl),a   ; 7
0516   425B             	;CALL UPDATE  ; will use DE, inc HL    77 clks
0517   425B                 ;jr lwt_start     ; 12
0518   425B             
0519   425B             
0520   425B             
0521   425B             
0522   425B             ;*
0523   425B             ;* Evaluate string  start of the string is in HL and the length in BC
0524   425B             ;*
0525   425B E7          NAME:	RST 20h
0526   425C CD 55 0F    	CALL 0F55h ; evaluate
0527   425F 3A 01 40    	LD A,(4001h)
0528   4262 87          	ADD A,A
0529   4263 FA 9A 0D    	JP M,0D9Ah  ; error
0530   4266 E1          	POP HL
0531   4267 D0          	RET NC
0532   4268 E5          	PUSH HL
0533   4269 CD F8 13    	CALL 13F8h ; get indexvar fom calc stack STK-FETCH
0534   426C                 ; For strings, the start of the string is in DE and the length in BC
0535   426C 62          	LD H,D
0536   426D 6B          	LD L,E
0537   426E C9          	RET
0538   426F             
0539   426F             
0540   426F             SEND_PACKET: ; HL points to data, C holds type, B lenght (0=256bytes), HL will point behind sent data afterwards
0541   426F F5              PUSH AF
0542   4270 C5              PUSH BC ; BC needed twice, for header, and recovered at end
0543   4271 C5              PUSH BC
0544   4272             
0545   4272 06 E1           LD B,225    ;   TODO 125 should be enough
0546   4274             SPWT:
0547   4274 10 FE           djnz SPWT     ; 500 microsec  (125*4)  ; let the video lines sync again, require 5 lines (320), some margin added
0548   4276             
0549   4276                 ; we want all our pulses in sync with the HSYNC pulses to not interfere   
0550   4276 AF              XOR A       ; make sure A' not at sync or display position to
0551   4277 08              EX AF,AF'   ; just cause short INT on MNI here:
0552   4278                             
0553   4278 D3 FE           OUT ($FE),A  ; ENABLE NMI
0554   427A 76              HALT
0555   427B D3 FD           OUT ($FD),A  ; Disable NMI   from here, start first bit in 54us =174cy
0556   427D DB FE           IN      A,($FE)         ; signal to 0 /on - syncout
0557   427F 7E              LD   A,(HL)     ; 7 dummy 
0558   4280 00              NOP             ; 4
0559   4281 06 07           LD   B,7
0560   4283 00              NOP             ; timing adjust to have bits symmetrical in (black-shouldered) line
0561   4284 D3 FF           OUT     ($FF),A ;11        ; signal to 1 / syncoff
0562   4286             waitnline:
0563   4286 10 FE           DJNZ waitnline          ; delay for next line 13 per loop ..
0564   4288 C1              POP  BC            ;10
0565   4289             
0566   4289             
0567   4289                 ; Send packettype in C
0568   4289             
0569   4289 CD CF 42        call SENDNIBBLE ;151, so we need 56 cycles between nibbles to get to 207 for one hsync line
0570   428C             
0571   428C 23              INC  HL         ; 6  ; DUMMY matching later dec
0572   428D 7E              LD   A,(HL)     ; 7 
0573   428E D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0574   4290 7E              LD   A,(HL)     ; 7 
0575   4291 7E              LD   A,(HL)     ; 7 
0576   4292 7E              LD   A,(HL)     ; 7 
0577   4293 7E              LD   A,(HL)     ; 7 
0578   4294 00              NOP
0579   4295             
0580   4295 CD CF 42        call SENDNIBBLE ;151
0581   4298             
0582   4298 2B              DEC  HL 
0583   4299 7E              LD   A,(HL)     ; 7 
0584   429A D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
0585   429C 7E              LD   A,(HL)     ; 7 
0586   429D 7E              LD   A,(HL)     ; 7 
0587   429E 7E              LD   A,(HL)     ; 7 
0588   429F 7E              LD   A,(HL)     ; 7 
0589   42A0 48              LD C,B             ;4
0590   42A1             
0591   42A1                 ; Send length in B
0592   42A1             
0593   42A1 CD CF 42        call SENDNIBBLE ;151
0594   42A4             
0595   42A4 23              INC  HL         ; 6  ; DUMMY matching later dec
0596   42A5 7E              LD   A,(HL)     ; 7 
0597   42A6 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0598   42A8 7E              LD   A,(HL)     ; 7 
0599   42A9 7E              LD   A,(HL)     ; 7 
0600   42AA 7E              LD   A,(HL)     ; 7 
0601   42AB 7E              LD   A,(HL)     ; 7 
0602   42AC 00              NOP             ; 4
0603   42AD             
0604   42AD CD CF 42        call SENDNIBBLE ;151
0605   42B0             
0606   42B0 2B              DEC  HL 
0607   42B1 7E              LD   A,(HL)     ; 7 
0608   42B2             byteloop:
0609   42B2 D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
0610   42B4 7E              LD   A,(HL)     ; 7 
0611   42B5 7E              LD   A,(HL)     ; 7 
0612   42B6 7E              LD   A,(HL)     ; 7 
0613   42B7 4E              LD   C,(HL)     ; 7 
0614   42B8 00              NOP
0615   42B9 CD CF 42        call SENDNIBBLE ;151
0616   42BC 23              INC  HL         ; 6
0617   42BD 7E              LD   A,(HL)     ; 7 
0618   42BE D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0619   42C0 7E              LD   A,(HL)     ; 7 
0620   42C1 7E              LD   A,(HL)     ; 7 
0621   42C2 7E              LD   A,(HL)     ; 7 
0622   42C3 7E              LD   A,(HL)     ; 7 
0623   42C4 00              NOP
0624   42C5                                 ; 56
0625   42C5 CD CF 42        CALL SENDNIBBLE ;151
0626   42C8 10 E8           DJNZ byteloop   ; 13
0627   42CA D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0628   42CC             
0629   42CC C1              POP  BC
0630   42CD F1              POP  AF
0631   42CE C9              ret
0632   42CF             
0633   42CF             
0634   42CF             SENDNIBBLE: ;31 per bit, 134 incl RET 151 incl call, nibble in C lower half
0635   42CF                 ; Four bits to send
0636   42CF                 ;# bit 1 start
0637   42CF CB 01           RLC C       ; 8
0638   42D1 38 19           JR C, csendH1 ; 12/7
0639   42D3 D8              ret c        ; 11/5 dummy for symmetric timing
0640   42D4                 ;# bit 1 send 0
0641   42D4 DB FE           IN      A,($FE)         ; signal to 0 /on
0642   42D6             
0643   42D6                 ;# bit 2 start
0644   42D6 CB 01           RLC C       ; 8
0645   42D8 38 2A           JR C, csendH2 ; 12/7
0646   42DA D8              ret c        ; 11/5 dummy for symmetric timing
0647   42DB                 ;# bit 2 send 0
0648   42DB DB FE           IN      A,($FE)         ; signal to 0 /on
0649   42DD             
0650   42DD                 ;# bit 3 start
0651   42DD CB 01           RLC C       ; 8
0652   42DF 38 34           JR C, csendH3 ; 12/7
0653   42E1 D8              ret c        ; 11/5 dummy for symmetric timing
0654   42E2                 ;# bit 3 send 0
0655   42E2 DB FE           IN      A,($FE)         ; signal to 0 /on
0656   42E4             
0657   42E4                 ;# bit 4 start
0658   42E4 CB 01           RLC C       ; 8
0659   42E6 38 37           JR C, csendH4 ; 12/7
0660   42E8 D8              ret c        ; 11/5 dummy for symmetric timing
0661   42E9                 ;# bit 4 send 0
0662   42E9 DB FE           IN      A,($FE)         ; signal to 0 /on
0663   42EB             
0664   42EB C9              ret
0665   42EC             
0666   42EC             
0667   42EC             csendH1:    ;# bit 1 send 1
0668   42EC D3 FF           OUT     ($FF),A         ; signal to 1 /off
0669   42EE             
0670   42EE                 ;# bit 2 start
0671   42EE CB 01           RLC C       ; 8
0672   42F0 38 12           JR C, csendH2 ; 12/7
0673   42F2 D8              ret c        ; 11/5 dummy for symmetric timing
0674   42F3                 ;# bit 2 send 0
0675   42F3 DB FE           IN      A,($FE)         ; signal to 0 /on
0676   42F5             
0677   42F5                 ;# bit 3 start
0678   42F5 CB 01           RLC C       ; 8
0679   42F7 38 1C           JR C, csendH3 ; 12/7
0680   42F9 D8              ret c        ; 11/5 dummy for symmetric timing
0681   42FA                 ;# bit 3 send 0
0682   42FA DB FE           IN      A,($FE)         ; signal to 0 /on
0683   42FC             
0684   42FC                 ;# bit 4 start
0685   42FC CB 01           RLC C       ; 8
0686   42FE 38 1F           JR C, csendH4 ; 12/7
0687   4300 D8              ret c        ; 11/5 dummy for symmetric timing
0688   4301                 ;# bit 4 send 0
0689   4301 DB FE           IN      A,($FE)         ; signal to 0 /on
0690   4303 C9              ret
0691   4304             
0692   4304             csendH2:    ;# bit 2 send 1
0693   4304 D3 FF           OUT     ($FF),A         ; signal to 1 /off
0694   4306             
0695   4306                 ;# bit 3 start
0696   4306 CB 01           RLC C       ; 8
0697   4308 38 0B           JR C, csendH3 ; 12/7
0698   430A D8              ret c        ; 11/5 dummy for symmetric timing
0699   430B                 ;# bit 3 send 0
0700   430B DB FE           IN      A,($FE)         ; signal to 0 /on
0701   430D             
0702   430D                 ;# bit 4 start
0703   430D CB 01           RLC C       ; 8
0704   430F 38 0E           JR C, csendH4 ; 12/7
0705   4311 D8              ret c        ; 11/5 dummy for symmetric timing
0706   4312                 ;# bit 4 send 0
0707   4312 DB FE           IN      A,($FE)         ; signal to 0 /on
0708   4314 C9              ret
0709   4315             
0710   4315             csendH3:    ;# bit 3 send 1
0711   4315 D3 FF           OUT     ($FF),A         ; signal to 1 /off
0712   4317             
0713   4317                 ;# bit 4 start
0714   4317 CB 01           RLC C       ; 8
0715   4319 38 04           JR C, csendH4 ; 12/7
0716   431B D8              ret c        ; 11/5 dummy for symmetric timing
0717   431C                 ;# bit 4 send 0
0718   431C DB FE           IN      A,($FE)         ; signal to 0 /on
0719   431E C9              ret
0720   431F             
0721   431F             csendH4:    ;# bit 4 send 1
0722   431F D3 FF           OUT     ($FF),A         ; signal to 1 /off
0723   4321 C9              ret
0724   4322             
0725   4322             
0726   4322             
0727   4322 76             db $76   ;N/L 
0728   4323             
0729   4323             line10:
0730   4323 00 0A          db 0,10  ;line number 
0731   4325 17 00          dw dfile-$-2  ;line length 
0732   4327 F5             db $f5   ;PRINT 
0733   4328 D4             db $d4   ;USR 
0734   4329 1D             db $1d   ;1 
0735   432A 22             db $22   ;6 
0736   432B 21             db $21   ;5 
0737   432C 1D             db $1d   ;1 
0738   432D 20             db $20   ;4 
0739   432E 7E             db $7e   ;FP mark 
0740   432F 8F             db $8f   ;5 bytes FP number 
0741   4330 01             db $01   ; 
0742   4331 04             db $04   ; 
0743   4332 00             db $00   ; 
0744   4333 00             db $00   ; 
0745   4334 1A             db $1a   ; ,
0746   4335 0B             db $0b   ; "
0747   4336 39             db c_T   ; TTTT2 = QLOAD test
0748   4337 39             db c_T   ; SNNN = dummy save for testing
0749   4338 39             db c_T   ; 
0750   4339 39             db c_T   ; 
0751   433A 1E             db c_0+2   ; 
0752   433B 0B             db $0b   ; "
0753   433C 76             db $76   ;N/L 
0754   433D 76             db $76   ;N/L 
0755   433E             
0756   433E             
0757   433E                
0758   433E             ;- Display file -------------------------------------------- 
0759   433E              
0760   433E             dfile: 
0761   433E 76             db $76 
0762   433F 3F 3D          db c_Z,c_X,
0763   4341 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
0763   4345 76 76 76 76 
0764   4349 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
0764   434D 76 76 76 76 
0765   4351 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
0765   4355 76 76 76 76 
0766   4359              
0767   4359             ;- BASIC-Variables ---------------------------------------- 
0768   4359              
0769   4359             var: 
0770   4359 80             db $80 
0771   435A              
0772   435A             ;- End of program area ---------------------------- 
0773   435A             
0774   435A             last: 
0775   435A              
0776   435A                end 
tasm: Number of errors = 0
