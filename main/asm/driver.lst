0001   0000             ; SYSINFO81 
0002   0000             ; 	GPL
0003   0000             ; 	Oliver Lange
0004   0000             ; 	Version 1.0.1
0005   0000             
0006   0000             ; Compile with "tasm -80 -b wspdrv.asm wspdrv.p" 
0007   0000             
0008   0000             
0009   0000             ; driver for wespi
0010   0000             ;
0011   0000             
0012   0000             
0013   0000              
0014   0000             #define db .byte ;  cross-assembler definitions 
0015   0000             #define dw .word 
0016   0000             #define ds .block 
0017   0000             #define org .org 
0018   0000             #define end .end 
0019   0000             
0020   0000             
0021   0000             
0022   0000             #define ADDR_DISABLE 0
0023   0000             #define UPDATE	01FCh	; LOAD/SAVE adress update subroutine in ROM
0024   0000             
0025   0000             ;;#define VERBOSE 1
0026   0000              
0027   4009             org     $4009 ; BASIC PROGRAMM
0028   4009             ;= System variables ============================================ 
0029   4009              
0030   4009 00             db 0     	;VERSN 
0031   400A 00 00          dw 0     	;E_PPC 
0032   400C 4F 44          dw dfile      ;D_FILE 
0033   400E 50 44          dw dfile+1    ;DF_CC 
0034   4010 6A 44          dw var   	;VARS 
0035   4012 00 00          dw 0     	;DEST 
0036   4014 6B 44          dw var+1      ;E_LINE 
0037   4016 6A 44          dw last-1     ;c_ADD 
0038   4018 00 00          dw 0     	;X_PTR 
0039   401A 6B 44          dw last  	;STKBOT 
0040   401C 6B 44          dw last  	;STKEND 
0041   401E 00             db 0     	;BERG 
0042   401F 5D 40          dw membot     ;MEM 
0043   4021 00             db 0     ;not used 
0044   4022 02             db 2     ;DF_SZ 
0045   4023 01 00          dw 1     ;S_TOP 
0046   4025 FF FF FF       db $FF,$FF,$FF     ;LAST_K 
0047   4028 37             db 55    ;MARGIN 
0048   4029 2C 44          dw line10     ;NXTLIN   line10   dfile
0049   402B 00 00          dw 0     ;OLDPPC 
0050   402D 00             db 0     ;FLAGX 
0051   402E 00 00          dw 0     ;STRLEN 
0052   4030 8D 0C          dw $0C8D      ;T_ADDR 
0053   4032 00 00          dw 0     ;SEED 
0054   4034 FF FF          dw $FFFF      ;FRAMES 
0055   4036 00 00          db 0,0   ;COORDS 
0056   4038 BC             db $BC   ;PR_CC 
0057   4039 21 18          db 33,24      ;S_POSN 
0058   403B 40             db 01000000B  ;CDFLAG 
0059   403C                ds 33    ;Print buffer --- now used for loader code, all loaded programs need to have the same !
0060   405D             
0061   405D             membot: 
0062   405D                ds 30    ;Calculator�s memory area 
0063   407B                ds 2     ;not used 
0064   407D              
0065   407D             ;= First BASIC line, asm code ================================== 
0066   407D              
0067   407D             line0: 
0068   407D 00 00          db 0,0   ;line number 
0069   407F AB 03          dw line10-$-2 ;line length 
0070   4081 EA             db $ea   ; REM 
0071   4082             
0072   4082             
0073   4082             #define ELINE	4014h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0074   4082             #define ELINEHI	4015h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0075   4082             
0076   4082             #define SHOW	0207h  ; ROM-Routinen
0077   4082             #define FAST	02E7h
0078   4082             #define RCLS	0A2Ah
0079   4082             #define GETKEY	02BBh
0080   4082             
0081   4082             
0082   4082             #DEFINE RST_PRTCHAR RST 10H
0083   4082             #DEFINE c_SPACE 0
0084   4082             #DEFINE c_NEWLINE 76H
0085   4082             #DEFINE c_0 1CH
0086   4082             
0087   4082             #DEFINE c_A 26H
0088   4082             #DEFINE c_B c_A+1
0089   4082             #DEFINE c_C c_A+2
0090   4082             #DEFINE c_D c_A+3
0091   4082             #DEFINE c_E c_A+4
0092   4082             #DEFINE c_F c_A+5
0093   4082             #DEFINE c_G c_A+6
0094   4082             #DEFINE c_H c_A+7
0095   4082             #DEFINE c_I c_A+8
0096   4082             #DEFINE c_J c_A+9
0097   4082             #DEFINE c_K c_J+1
0098   4082             #DEFINE c_L c_J+2
0099   4082             #DEFINE c_M c_J+3
0100   4082             #DEFINE c_N c_J+4
0101   4082             #DEFINE c_O c_J+5
0102   4082             #DEFINE c_P c_J+6
0103   4082             #DEFINE c_Q c_J+7
0104   4082             #DEFINE c_R c_J+8
0105   4082             #DEFINE c_S c_J+9
0106   4082             #DEFINE c_T c_S+1
0107   4082             #DEFINE c_U c_S+2
0108   4082             #DEFINE c_V c_S+3
0109   4082             #DEFINE c_W c_S+4
0110   4082             #DEFINE c_X c_S+5
0111   4082             #DEFINE c_Y c_S+6
0112   4082             #DEFINE c_Z c_S+7
0113   4082             
0114   4082             #define UFM_ERRNO 16434 ; Definiert in UFM, Fehlercode 1 Byte (eigentlich SEED)
0115   4082             #define UFM_CMDBUF 16444 ; Definiert in UFM, 32 Byte, alternative Kommando�bergabe (eigentlich PRBUF)
0116   4082             #define UFM_COORDS 16438 ; L�ngen�bergabe 2 Byte (eigentlich COORDS)
0117   4082             
0118   4082             
0119   4082             ;
0120   4082             ;   === Main entry point ====
0121   4082             ;
0122   4082             
0123   4082             BASIC_START:
0124   4082 CD 64 43    	CALL NAME	; get command line arg
0125   4085 18 1B       	JR BASIC_CONT
0126   4087 00          	NOP
0127   4088 00          	NOP
0128   4089 00          	NOP
0129   408A             
0130   408A             CALL_START:	; (IN UFM als START_ADDR+6 festgelegt)
0131   408A 21 3C 40    	LD HL,UFM_CMDBUF
0132   408D E5              PUSH HL
0133   408E                 ;  get length in BC by parsing for '"' or so..
0134   408E 01 00 00        LD   BC,0
0135   4091             ENDPRSLP:
0136   4091 7E              LD   A,(HL)
0137   4092 FE 0B           CP   11     ; is " ?
0138   4094 28 04           JR   Z, EXITPRSLP
0139   4096 03              INC  BC
0140   4097 23              INC  HL
0141   4098 18 F7           JR   ENDPRSLP
0142   409A             EXITPRSLP:
0143   409A E1              POP  HL ; original pointer
0144   409B CD B8 40    	CALL GENER_START
0145   409E 32 32 40    	LD (UFM_ERRNO),A
0146   40A1 C9          	RET
0147   40A2             
0148   40A2             BASIC_CONT:
0149   40A2 CD B8 40    	CALL GENER_START ; A is 0 for ok, !=0 for error
0150   40A5 A7          	AND A
0151   40A6 28 0F       	JR Z,BAS_OK
0152   40A8 3E 2A       	LD A,c_E		; Ausgabe ERR
0153   40AA D7          	RST 10h 
0154   40AB 3E 37       	LD A,c_R
0155   40AD D7          	RST 10h
0156   40AE 3E 37           LD A,c_R
0157   40B0 D7          	RST 10h
0158   40B1 3E 76           LD A,c_NEWLINE
0159   40B3 D7          	RST 10h
0160   40B4                 ; exit
0161   40B4 AF              XOR A
0162   40B5 CF          	RST 08h
0163   40B6 09              db  09h             ; Error Report: Invalid argument
0164   40B7             	;db 0FFh
0165   40B7             
0166   40B7             BAS_OK:
0167   40B7 C9          	RET  ; TODO check if RET or better RST8 with -1
0168   40B8             ;    XOR A		; sonst zurueck nach BASIC
0169   40B8             ;	RST 08h
0170   40B8             ;	db 0FFh
0171   40B8             	
0172   40B8             
0173   40B8             GENER_START: ; Interpreting the string independent of its origin, on ret A=0 for okay, BC retval to basic
0174   40B8 7E          	LD A,(HL)   ; HL=start, BC=length
0175   40B9 23              INC  HL
0176   40BA 0B              DEC  BC
0177   40BB 11 D9 40        LD   DE,GENER_END
0178   40BE D5              PUSH DE     ; ret adddess
0179   40BF             ;	CP c_I		; Info
0180   40BF             ;	JP Z,INFO1
0181   40BF FE 38       	CP c_S		; Save
0182   40C1 CA D9 41    	JP Z,SAVE1
0183   40C4 FE 31       	CP c_L		; Load
0184   40C6 CA 09 41    	JP Z,LOAD1
0185   40C9             ;	CP 29h		; ist es ein D;
0186   40C9             ;	JP Z,DIR1
0187   40C9             ;	CP 3Bh		; ist es ein V (UFM)
0188   40C9             ;	JP Z,DIRV1
0189   40C9             ;	CP 30h		; ist es ein K (UFM)
0190   40C9             ;	JP Z,DIRK1
0191   40C9             ;	CP 37h		; ist es ein R
0192   40C9             ;	JP Z,RENAM1
0193   40C9             ;	CP 2Ah		; ist es ein E
0194   40C9             ;	JP Z,ERAS1
0195   40C9 FE 39       	CP c_T		; Test, return 0...1023 dependng on number of correct bytes
0196   40CB CA AD 41    	JP Z,TESTPATTERN
0197   40CE FE 2D       	CP c_H		; Help
0198   40D0 CA CF 42    	JP Z,HLP
0199   40D3 FE 0F       	CP 0Fh		; ist es ein ?
0200   40D5 CA CF 42    	JP Z,HLP
0201   40D8 C9              ret 
0202   40D9             
0203   40D9             GENER_END:
0204   40D9 F5              PUSH AF ; holds our error status
0205   40DA C5              PUSH BC ; ret value...
0206   40DB CD 07 02    	CALL SHOW
0207   40DE C1              POP  BC
0208   40DF F1              POP  AF
0209   40E0 C9          	RET
0210   40E1             	
0211   40E1             
0212   40E1             
0213   40E1             
0214   40E1             CHECKCOMMA:  ; Z is set when comma seperator found in string, NZ if not, uses A
0215   40E1                 ; BC =0?
0216   40E1 AF              XOR  A
0217   40E2 B9              CP   C
0218   40E3 20 02           JR   NZ,CHKK_CONT
0219   40E5 3C              INC  A ; clear the Z flag
0220   40E6 C9              RET     ; no match till end
0221   40E7             CHKK_CONT:
0222   40E7 7E              LD   A, (HL)
0223   40E8 FE 1A           CP   26     ; comma
0224   40EA C8              RET  z
0225   40EB FE 1A           CP   26     ; also check for semicolon
0226   40ED C8              RET  z
0227   40EE 23              INC  HL
0228   40EF 0B              DEC  BC
0229   40F0 18 EF           JR CHECKCOMMA
0230   40F2             
0231   40F2             
0232   40F2             SKIPEMPTY:  ; Z is set when comma seperator found in string, NZ if not, uses A
0233   40F2                 ; BC =0?
0234   40F2 AF              XOR  A
0235   40F3 B9              CP   C
0236   40F4 20 05           JR   NZ,CHKE_CONT
0237   40F6 B8              CP   B
0238   40F7 20 02           JR   NZ,CHKE_CONT
0239   40F9 3C              INC  A ; clear the Z flag
0240   40FA C9              RET     ; no match till end
0241   40FB             CHKE_CONT:
0242   40FB BE              CP   (HL)
0243   40FC C0              RET  NZ ; not empty,leave
0244   40FD 23              INC  HL
0245   40FE 0B              DEC  BC
0246   40FF 18 F1           JR SKIPEMPTY
0247   4101             
0248   4101             PRINTA:
0249   4101 E5              PUSH HL
0250   4102 D5              PUSH DE
0251   4103 C5              PUSH BC
0252   4104 D7              RST 10H
0253   4105 C1              POP  BC
0254   4106 D1              POP  DE
0255   4107 E1              POP  HL
0256   4108 C9              RET
0257   4109                 
0258   4109             
0259   4109             LOAD1:
0260   4109             	; HL points to arg string, BC number of chars
0261   4109 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0262   410A C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0263   410B                 ; Check if we have contact
0264   410B 3E 31           LD   A, c_L
0265   410D CD 01 41        CALL PRINTA
0266   4110                 
0267   4110 CD FB 42        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0268   4113 A7              AND A
0269   4114                 ; Send LOAD request
0270   4114 C1              POP  BC
0271   4115 E1              POP  HL ; recover name pointer/length
0272   4116 28 4B           JR   Z, LD_ERR ; NO CONTACT after TRY_HANDSHAKE
0273   4118 E5              PUSH HL  ; and again store for binload
0274   4119 C5              PUSH BC  ; 
0275   411A             
0276   411A 41              ld   B,C ; length, assume <256
0277   411B 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0278   411D CD 78 43        call SEND_PACKET
0279   4120             
0280   4120                 ; now retrieve key, must be 123
0281   4120 CD 4A 43        CALL QLD_GETBYTE    ; uses BC D, result in A
0282   4123 FE 7B           CP  123
0283   4125 20 3A           JR NZ,LD_ERR2
0284   4127 06 04           LD   B,4
0285   4129 7E              LD  A,(HL)  ; dummy for timing
0286   412A              
0287   412A             LOADELY1:         ;    //47 delay between the header bytes
0288   412A 10 FE           DJNZ LOADELY1
0289   412C             
0290   412C                 ; now retrieve length, 0 for error
0291   412C CD 4A 43        CALL QLD_GETBYTE    ; uses BC D, result in A
0292   412F 6F              LD   L,A
0293   4130 06 05           LD   B,5
0294   4132             
0295   4132             LOADELY2:         ;    //60 delay between the length bytes
0296   4132 10 FE           DJNZ LOADELY2
0297   4134             
0298   4134 00              NOP
0299   4135 CD 4A 43        CALL QLD_GETBYTE    ; uses BC D, result in A
0300   4138 67              LD   H,A
0301   4139 B5              OR   L
0302   413A 28 25           JR Z,LD_ERR2
0303   413C EB              EX   DE,HL
0304   413D                 ; Here we have DE= len
0305   413D                 ; get addr
0306   413D C1              POP  BC
0307   413E E1              POP  HL ; recover name pointer/length
0308   413F D5              PUSH DE             ; length, will go to BC below
0309   4140 D5              PUSH DE             ; length, again, for end result
0310   4141             
0311   4141             
0312   4141                 ;  test if saving binary or regular basic
0313   4141 CD E1 40        CALL CHECKCOMMA
0314   4144 28 20           JR   Z, BINLOAD
0315   4146             
0316   4146                 ; LOAD BASIC program if not BINLOAD, set addr
0317   4146 21 09 40    	LD HL,4009h		; 
0318   4149 1E 01           LD   E,1        ; mark as basic load
0319   414B             
0320   414B             LOADLOOP:
0321   414B                 ; timing  - 74 between calls seems to be more reliable than 70!
0322   414B CD 4A 43        CALL QLD_GETBYTE    ; uses BC D, result in A
0323   414E 77              LD   (HL),A
0324   414F 77              LD   (HL),A ; dummy for timing
0325   4150 23              INC  HL
0326   4151 C1              POP  BC     ; get remaining length
0327   4152 0B              DEC  BC
0328   4153 79              LD   A,C
0329   4154 B0              OR   B
0330   4155 28 03           JR Z, LD_END
0331   4157 C5              PUSH BC
0332   4158 18 F1           JR  LOADLOOP
0333   415A             LD_END:  
0334   415A C1              POP  BC ; orig length
0335   415B AF              XOR  A
0336   415C BB              CP   E  ; 0 for binary
0337   415D C8              RET   Z ; normal return for binload with length in BC
0338   415E                 ; end for BASIC loader
0339   415E D1              POP  DE ; dummy, ret addr
0340   415F CF          	RST 08h ;
0341   4160 FF          	db 0FFh
0342   4161             
0343   4161             
0344   4161             LD_ERR2:
0345   4161 D1              POP  DE ; dummy
0346   4162 D1              POP  DE ; dummy
0347   4163             LD_ERR:
0348   4163 3E 01           LD   A,1
0349   4165 C9              RET ; BC WILL be at maximum now
0350   4166             
0351   4166             
0352   4166             
0353   4166             BINLOAD: ; HL points to the comma in arg string, now parse addr, length
0354   4166 23              INC  HL
0355   4167 0D              DEC  C
0356   4168 CD 72 41        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0357   416B 20 F4           JR NZ, LD_ERR2   ; parse error
0358   416D                 ; addr in DE
0359   416D EB              EX   DE,HL
0360   416E 1E 00           LD   E,0    ; mark as binary
0361   4170 18 D9           JR LOADLOOP
0362   4172             
0363   4172             
0364   4172             
0365   4172             ; parse a decimal number
0366   4172             PARS_DEC_NUM:   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0367   4172 11 00 00    	LD DE, 0
0368   4175 AF              XOR  A
0369   4176 B9              CP   C
0370   4177 28 31           JR Z,PARSFAIL
0371   4179             
0372   4179             PARS_LLOOP:     ; look for first number
0373   4179 7E          	LD A,(HL)
0374   417A A7          	AND A
0375   417B 28 FC       	JR Z, PARS_LLOOP ; skip whitespace
0376   417D             PARS_LLP2:
0377   417D D6 1C       	SUB 01ch	;"0"
0378   417F DA AA 41    	JP C,PARSFAIL
0379   4182 FE 0A       	CP 10
0380   4184 D2 AA 41    	JP NC,PARSFAIL
0381   4187             	; have a digit in A,
0382   4187 E5          	PUSH HL
0383   4188             	; DE times ten
0384   4188 62          	LD H,D      ; now in both HL and DE
0385   4189 6B          	LD L,E
0386   418A 29          	ADD HL,HL
0387   418B 29          	ADD HL,HL
0388   418C 29          	ADD HL,HL ; times 8 so far
0389   418D 19          	ADD HL,DE
0390   418E 19          	ADD HL,DE
0391   418F             	; Add new digit
0392   418F 16 00       	LD D,0
0393   4191 5F          	LD E,A
0394   4192 19          	ADD HL,DE
0395   4193 EB          	EX DE,HL    ; new value of DE
0396   4194 E1          	POP HL  ; pointer to argline back in HL
0397   4195 23          	INC HL
0398   4196 0D          	DEC C
0399   4197 28 0F           JR Z,PARSDONE
0400   4199 7E          	LD A,(HL)   ; load next char to see if end
0401   419A FE 1A           CP   26 ;  ','
0402   419C 28 0A           JR Z,PARSDONE
0403   419E FE 0E           CP   14 ;  ';'
0404   41A0 28 06           JR Z,PARSDONE
0405   41A2 FE 0B           CP   11 ;  '"'
0406   41A4 28 02           JR Z,PARSDONE
0407   41A6 18 D5       	JR PARS_LLP2 
0408   41A8             PARSDONE:
0409   41A8 AF              XOR  A
0410   41A9 C9          	RET
0411   41AA             PARSFAIL:
0412   41AA AF              XOR  A
0413   41AB 3C              INC  A
0414   41AC C9          	RET
0415   41AD             
0416   41AD             
0417   41AD             TESTPATTERN:
0418   41AD             	; HL points to arg string, BC number of chars
0419   41AD E5              PUSH HL  ; orig pos of args (w/o prefix T)
0420   41AE C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0421   41AF                 ; Check if we have contact
0422   41AF             ;    LD   A, c_T
0423   41AF             ;    CALL PRINTA
0424   41AF                 
0425   41AF CD FB 42        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0426   41B2 A7              AND A
0427   41B3                 ; Send LOAD request
0428   41B3 C1              POP  BC
0429   41B4 E1              POP  HL ; recover name pointer/length
0430   41B5 28 1C           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0431   41B7             
0432   41B7 41              ld   B,C ; length, assume <256
0433   41B8 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0434   41BA CD 78 43        call SEND_PACKET
0435   41BD             
0436   41BD                 ; now retrieve 1024 bytes and see how many are correct
0437   41BD                 ; gap between byte calls should be 77+12+7 - 17-10 = 69 clocks
0438   41BD 01 00 00        LD   BC,0
0439   41C0             TESTBLOOP:
0440   41C0 C5              PUSH BC
0441   41C1 00              NOP         ; timing adjust 66/70
0442   41C2 00              NOP         ; timing adjust 70/74 - 74 seems to be more reliable than 70!
0443   41C3 CD 4A 43        CALL QLD_GETBYTE    ; uses BC D, result in A
0444   41C6 C1              POP  BC
0445   41C7 B9              CP   C  ; incomming data in A is 0,1,2,3,4...255,0,1... as byte
0446   41C8 3E 00           LD   A,0 ; not affect flags, test never reports errors to better automatize
0447   41CA C0              RET  NZ ; report BC at point of first failure
0448   41CB 03              INC  BC
0449   41CC 3E 10           LD   A,16 ; 4kbyte testsize
0450   41CE B8              CP   B
0451   41CF 20 EF           JR   NZ, TESTBLOOP
0452   41D1 AF              XOR  A
0453   41D2 C9              RET ; BC WILL be at maximum now
0454   41D3             
0455   41D3             
0456   41D3             
0457   41D3             ERREXIT:
0458   41D3 3E 01           LD   A,1
0459   41D5 01 00 00        LD   BC,0
0460   41D8 C9              RET
0461   41D9             
0462   41D9             SAVE1:
0463   41D9             	; HL points to arg string, BC number of chars
0464   41D9 E5              PUSH HL  ; orig pos of args (w/o prefix S)
0465   41DA C5              PUSH BC  ; orig lenght of args (w/o prefix S)
0466   41DB             
0467   41DB             
0468   41DB 3E 38           LD   A, c_S
0469   41DD CD 01 41        CALL PRINTA
0470   41E0             
0471   41E0                 ; Check if we have contact
0472   41E0                
0473   41E0 CD FB 42        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0474   41E3                 ; Send SAVE request
0475   41E3 C1              POP  BC
0476   41E4 E1              POP  HL ; recover name pointer/length
0477   41E5                 ; evauate connect result
0478   41E5 A7              AND A
0479   41E6 28 EB           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0480   41E8             
0481   41E8                 ; again store original argument string, will need it now and when sending name
0482   41E8 E5              PUSH HL
0483   41E9 C5              PUSH BC
0484   41EA             
0485   41EA                 ;  test if saving binary or regular basic
0486   41EA CD E1 40        CALL CHECKCOMMA
0487   41ED 28 43           JR   Z, BINSAVE
0488   41EF             
0489   41EF                 ; SAVE BASIC program if not BINSAVE, pre-calc addr,size into HL and BC
0490   41EF 11 09 40    	LD DE,4009h		; Get length
0491   41F2 2A 14 40    	LD HL,(ELINE)	
0492   41F5 A7          	AND A		; clear carry
0493   41F6 ED 52       	SBC HL,DE	; HL=length
0494   41F8 44          	LD B,H
0495   41F9 4D          	LD C,L
0496   41FA EB          	EX DE,HL	; Now HL=Start, BC=length
0497   41FB             
0498   41FB             SAVE_CONT: ;continue common path of BIN and BASIC save
0499   41FB D9              EXX     ; store payload addr and length for now
0500   41FC EB          	EX DE,HL	; HL' must be restored, save in DE'
0501   41FD C1              POP  BC
0502   41FE E1              POP  HL ; recover name pointer/length
0503   41FF CD F2 40        CALL SKIPEMPTY 
0504   4202 AF              XOR  A
0505   4203 B9              CP   C
0506   4204 28 40           JR   Z, ERREXIT3 ; NO NAME
0507   4206 41              ld   B,C ; length, assume <256
0508   4207 0E 5B           ld   C,91 ; packet ID ZX_QSAVE_TAG_SAVEPFILE
0509   4209 CD 78 43        call SEND_PACKET
0510   420C EB          	EX DE,HL	; HL' must be restored, was saved in DE'
0511   420D D9              EXX ; Recover, now HL=Start, BC=length
0512   420E             	
0513   420E             SVSENDFUL:
0514   420E AF              XOR  A
0515   420F B8              CP   B
0516   4210 28 0C           JR   Z, SVSENDLAST
0517   4212                 ; send full packets
0518   4212 C5              PUSH BC
0519   4213 06 00           LD   B,0    ; 256 bytes
0520   4215 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0521   4217 CD 78 43        call SEND_PACKET
0522   421A C1              POP  BC
0523   421B 05              DEC  B
0524   421C 18 F0           JR   SVSENDFUL
0525   421E             
0526   421E             SVSENDLAST:
0527   421E AF              XOR  A
0528   421F B9              CP   C
0529   4220 28 06           JR   Z, SVSENDEND
0530   4222 41              LD   B,C ; length
0531   4223 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0532   4225 CD 78 43        call SEND_PACKET
0533   4228             
0534   4228             SVSENDEND:
0535   4228 CD 30 43        CALL QS_FINAL_ACK   ; Z set for success
0536   422B 20 A6           JR   NZ, ERREXIT
0537   422D AF              XOR  A
0538   422E 01 01 00        LD   BC, 1
0539   4231 C9          	RET
0540   4232             
0541   4232             
0542   4232             BINSAVE: ; HL points to the comma in arg string, now parse addr, length
0543   4232 23              INC  HL
0544   4233 0D              DEC  C
0545   4234 CD 72 41        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0546   4237 20 13           JR NZ, BSERREXIT   ; parse error
0547   4239 D5              PUSH DE ; store addr, from now on have to use BSERREXIT2 to stack-unwind here
0548   423A 23              INC  HL
0549   423B 0D              DEC  C
0550   423C CD 72 41        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0551   423F 20 0A           JR NZ, BSERREXIT2   ; parse error
0552   4241                 ; length in DE
0553   4241                 ; Now put HL=Start, BC=length
0554   4241 42              LD   B,D
0555   4242 4B              LD   C,E
0556   4243 E1              POP  HL
0557   4244 18 B5           JR SAVE_CONT
0558   4246             
0559   4246             ERREXIT3:
0560   4246 EB          	EX DE,HL	; HL' must be restored, saved in DE'
0561   4247 D9              EXX ; Recover
0562   4248 3E 01           LD   A,1
0563   424A C9          	RET
0564   424B             
0565   424B             BSERREXIT2:
0566   424B D1              POP  DE
0567   424C             BSERREXIT:
0568   424C C1              POP  BC
0569   424D E1              POP  HL ; recover name pointer/length
0570   424E 3E 01           LD   A,1
0571   4250 C9          	RET
0572   4251             
0573   4251             
0574   4251             HLPTXT:
0575   4251 3F 3D 00 3C 	db c_Z,c_X,0,c_W,c_E,c_S,c_P,c_I,0,c_D,c_R,c_I,c_V,c_E,c_R,0, c_0,27,c_0+1,c_0,c_0,c_NEWLINE
0575   4255 2A 38 35 2E 
0575   4259 00 29 37 2E 
0575   425D 3B 2A 37 00 
0575   4261 1C 1B 1D 1C 
0575   4265 1C 76 
0576   4267 76              db c_NEWLINE
0577   4268             ;	db "INFO  ",22h,"I",22h,0dh
0578   4268             ;	db "DIR   ",22h,"D",22h,0dh
0579   4268             ;	db "ERASE ",22h,"ENAME.P",22h,0dh
0580   4268             ;	db "MKDIR ",22h,"DMVERZ",22h,0dh
0581   4268             ;	db "RMDIR ",22h,"DEVERZ",22h,0dh
0582   4268             ;	db "CHDIR ",22h,"DCVERZ",22h,0dh
0583   4268 31 34 26 29 	db c_L,c_O,c_A,c_D, 0 , 0 , 0, 11, c_L, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "LOAD  ",22h,"LNAME.P",22h,0dh
0583   426C 00 00 00 0B 
0583   4270 31 33 26 32 
0583   4274 2A 0B 76 
0584   4277 27 31 34 26 	db c_B,c_L,c_O,c_A,c_D, 0 , 0, 11, c_L, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 11,c_NEWLINE   ; "BLOAD ",22h,"LNAME.B,SSSS",22h,0dh
0584   427B 29 00 00 0B 
0584   427F 31 33 26 32 
0584   4283 2A 1A 26 29 
0584   4287 29 37 0B 76 
0585   428B             ;	db "BLOAD ",22h,"LNAME.B,SSSS",22h,0dh
0586   428B 38 26 3B 2A 	db c_S,c_A,c_V,c_E, 0 , 0 , 0, 11, c_S, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0586   428F 00 00 00 0B 
0586   4293 38 33 26 32 
0586   4297 2A 0B 76 
0587   429A 27 38 26 3B 	db c_B,c_S,c_A,c_V,c_E, 0 , 0, 11, c_S, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 26, c_L, c_E, c_N,  11,c_NEWLINE   ; "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0587   429E 2A 00 00 0B 
0587   42A2 38 33 26 32 
0587   42A6 2A 1A 26 29 
0587   42AA 29 37 1A 31 
0587   42AE 2A 33 0B 76 
0588   42B2             ;	db "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0589   42B2             ;	db "RENAME",22h,"ROLDNAME NEWNAME",22h,0dh
0590   42B2 39 2A 38 39 	db c_T,c_E,c_S,c_T, 0 , 0 , 0, 11, c_T, c_L, c_T, c_T, c_T, c_0+2, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0590   42B6 00 00 00 0B 
0590   42BA 39 31 39 39 
0590   42BE 39 1E 0B 76 
0591   42C2 2D 2A 31 35 	db c_H,c_E,c_L,c_P, 0 , 0 , 0, 11, c_H, 11,c_NEWLINE   ;  c_H,   "HELP  ",22h,"H",22h,0dh
0591   42C6 00 00 00 0B 
0591   42CA 2D 0B 76 
0592   42CD             ;	db "FOR SIGGI'S UFM :V/R/K",0dh
0593   42CD 76              db c_NEWLINE
0594   42CE FF          	db $ff
0595   42CF             
0596   42CF             
0597   42CF             ; === Subroutine print help text ====
0598   42CF             
0599   42CF 21 51 42    HLP:	LD HL,HLPTXT
0600   42D2 7E          HLP1:	LD A,(HL)
0601   42D3 FE FF       	CP $FF
0602   42D5 28 04       	JR Z, EXITHLP
0603   42D7 D7              RST 10H
0604   42D8 23          	INC HL
0605   42D9 18 F7       	JR HLP1
0606   42DB             EXITHLP:
0607   42DB 01 2A 00        LD   BC,42
0608   42DE AF              XOR  A
0609   42DF C9              RET
0610   42E0             
0611   42E0             
0612   42E0             
0613   42E0             GO_QSAVE_MODE:
0614   42E0 CD E7 02    	CALL FAST	; go to fast mode
0615   42E3 DB FE           IN      A,($FE)         ; signal to 0 pause    
0616   42E5 06 C8           LD B,200  ; 200=200ms Pause
0617   42E7 C5          W1: push BC
0618   42E8 06 00           ld b,0
0619   42EA             W2:
0620   42EA 10 FE           djnz W2     ; 1 millisec (256*4)
0621   42EC C1              pop BC
0622   42ED 10 F8           djnz W1
0623   42EF 1E 4B           LD E, 75    ; ID for ZX_SAVE_TAG_QSAVE_START
0624   42F1 CD 1F 03        call $031F  ; SAVE byte in E
0625   42F4 D3 FF           OUT     ($FF),A         ; ; signal to 1 / syncoff, send hsyncs
0626   42F6 06 00           ld b,0
0627   42F8             W4:
0628   42F8 10 FE           djnz W4     ; 1 millisec (256*4) to go to QSAVE mode
0629   42FA C9              RET
0630   42FB             
0631   42FB             TRY_HANDSHAKE:  ; See if WESPI responds, return 1 if so, 0 for timeout
0632   42FB CD E0 42        CALL GO_QSAVE_MODE
0633   42FE 21 04 40        ld   hl, 16388 ; RAMTOP
0634   4301 06 02           ld   B,2
0635   4303 0E 5A           ld   C,90 ; packet ID ZX_QSAVE_TAG_HANDSHAKE
0636   4305 CD 78 43        call SEND_PACKET
0637   4308 06 B5           ld   b,181  ; timeout, 500ms (inner loop 3.15ms)
0638   430A             HS_LOOP1:
0639   430A C5              PUSH BC
0640   430B 06 00           LD   B,0
0641   430D             HS_LOOP2:                  ; 35 cycles=10.7us, inner Loop 2.75 millisec
0642   430D DB FE           in a,($FE)  ; 11
0643   430F 17              rla         ; 4
0644   4310 38 0E           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0645   4312 10 F9           DJNZ HS_LOOP2 ;13
0646   4314                 ; re-check here to not have a blind spot for outer loop
0647   4314 DB FE           in a,($FE)  ; 11
0648   4316 17              rla         ; 4
0649   4317 38 07           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0650   4319 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff in between to not let levels drift (not good for follow-up cmds?)
0651   431B C1              POP  BC
0652   431C 10 EC           DJNZ HS_LOOP1
0653   431E                 ; no signal found
0654   431E AF              XOR  A
0655   431F C9              RET
0656   4320             
0657   4320             HS_FOUND
0658   4320 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff
0659   4322                 ; let the output recover with active signal after being low from input. takes about 1ms as seen in oscilloscope
0660   4322 06 00           LD   B,0
0661   4324             HS_FINALDELAY: ; 3ms here before next cmd
0662   4324 7E              LD   A,(HL)
0663   4325 7E              LD   A,(HL)
0664   4326 7E              LD   A,(HL)    
0665   4327 7E              LD   A,(HL)    
0666   4328 10 FA           DJNZ HS_FINALDELAY
0667   432A C1              POP  BC
0668   432B 3E 01           LD   A,1
0669   432D A7              AND  A
0670   432E C9              RET
0671   432F             
0672   432F             QS_FINAL_SZ:
0673   432F 00              db 0 ; size of return packet to request, use smallest possible
0674   4330             
0675   4330             QS_FINAL_ACK:  ; Get info is operation was sussessful (Z) or failed (NZ), USES BC DE HL, A
0676   4330 21 2F 43        ld   hl, QS_FINAL_SZ ; Requested length
0677   4333 06 01           ld   B,1
0678   4335 0E 63           LD   C,99 ; packet ID ZX_QSAVE_TAG_END_RQ
0679   4337 CD 78 43        call SEND_PACKET
0680   433A             
0681   433A                 ; await reply, first byte is tag, then result
0682   433A CD 4A 43        CALL QLD_GETBYTE
0683   433D FE 2A           CP   42 ; tag
0684   433F C0              RET  NZ
0685   4340 06 08           ld B,8  ; 
0686   4342             QSFDLY:
0687   4342 10 0F           djnz lgapdly     ; 13*n-5 = 47 for 4
0688   4344 CD 4A 43        CALL QLD_GETBYTE
0689   4347 FE 01           CP   1 ; result
0690   4349 C9              RET    ; Z on match
0691   434A             
0692   434A             
0693   434A             
0694   434A             ; gab between byte calls should be 77+12+7 - 17-10 = 69 clocks
0695   434A             
0696   434A             QLD_GETBYTE:    ; uses BC D, result in A
0697   434A 0E FE           ld c,$fe   ; 7
0698   434C 06 08           ld b,8  ; 7    for gap between start and bits
0699   434E             
0700   434E             lwt_stdly:                  ; 25 cycles=7.7us
0701   434E DB FE           in a,($FE)  ; 11
0702   4350 17              rla         ; 4
0703   4351 30 FB           jr nc,lwt_stdly ; 12 / 7  (D7=0 is low level, wait for high)
0704   4353                 ; trigger is seen 4us too late in average, so wait 48-4 - 4 us now: 130 cy in-in
0705   4353             lgapdly:
0706   4353 10 FE           djnz lgapdly     ; 13*n-5 = 99 for 8
0707   4355 06 08           ld b,8  ; 7
0708   4357             lbloop:                 ;  need 104 for 32us
0709   4357 ED 50           in d,(c)    ; 12
0710   4359 CB 12           rl d        ; 8
0711   435B 17              rla         ; 4 (rl a is 8)
0712   435C 16 04           ld d,4      ; 7
0713   435E             lbdly:
0714   435E 15              dec d          ; 4          b*16-5 = 59
0715   435F 20 FD           jr nz,lbdly     ; 12 / 7
0716   4361 10 F4           djnz lbloop     ; 13 / 8
0717   4363 C9              RET     
0718   4364                 
0719   4364                 ;ORIGINAL:
0720   4364                 ;ld (hl),a   ; 7
0721   4364             	;CALL UPDATE  ; will use DE, inc HL    77 clks
0722   4364                 ;jr lwt_start     ; 12
0723   4364             
0724   4364             
0725   4364             
0726   4364             
0727   4364             ;*
0728   4364             ;* Evaluate string  start of the string is in HL and the length in BC
0729   4364             ;*
0730   4364 E7          NAME:	RST 20h
0731   4365 CD 55 0F    	CALL 0F55h ; evaluate
0732   4368 3A 01 40    	LD A,(4001h)
0733   436B 87          	ADD A,A
0734   436C FA 9A 0D    	JP M,0D9Ah  ; error
0735   436F E1          	POP HL
0736   4370 D0          	RET NC
0737   4371 E5          	PUSH HL
0738   4372 CD F8 13    	CALL 13F8h ; get indexvar fom calc stack STK-FETCH
0739   4375                 ; For strings, the start of the string is in DE and the length in BC
0740   4375 62          	LD H,D
0741   4376 6B          	LD L,E
0742   4377 C9          	RET
0743   4378             
0744   4378             
0745   4378             SEND_PACKET: ; HL points to data, C holds type, B lenght (0=256bytes), HL will point behind sent data afterwards
0746   4378 F5              PUSH AF
0747   4379 C5              PUSH BC ; BC needed twice, for header, and recovered at end
0748   437A C5              PUSH BC
0749   437B             
0750   437B 06 E1           LD B,225    ;   TODO 125 should be enough
0751   437D             SPWT:
0752   437D 10 FE           djnz SPWT     ; 500 microsec  (125*4)  ; let the video lines sync again, require 5 lines (320), some margin added
0753   437F             
0754   437F                 ; we want all our pulses in sync with the HSYNC pulses to not interfere   
0755   437F AF              XOR A       ; make sure A' not at sync or display position to
0756   4380 08              EX AF,AF'   ; just cause short INT on MNI here:
0757   4381                             
0758   4381 D3 FE           OUT ($FE),A  ; ENABLE NMI
0759   4383 76              HALT
0760   4384 D3 FD           OUT ($FD),A  ; Disable NMI   from here, start first bit in 54us =174cy
0761   4386 DB FE           IN      A,($FE)         ; signal to 0 /on - syncout
0762   4388 7E              LD   A,(HL)     ; 7 dummy 
0763   4389 00              NOP             ; 4
0764   438A 06 07           LD   B,7
0765   438C 00              NOP             ; timing adjust to have bits symmetrical in (black-shouldered) line
0766   438D D3 FF           OUT     ($FF),A ;11        ; signal to 1 / syncoff
0767   438F             waitnline:
0768   438F 10 FE           DJNZ waitnline          ; delay for next line 13 per loop ..
0769   4391 C1              POP  BC            ;10
0770   4392             
0771   4392             
0772   4392                 ; Send packettype in C
0773   4392             
0774   4392 CD D8 43        call SENDNIBBLE ;151, so we need 56 cycles between nibbles to get to 207 for one hsync line
0775   4395             
0776   4395 23              INC  HL         ; 6  ; DUMMY matching later dec
0777   4396 7E              LD   A,(HL)     ; 7 
0778   4397 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0779   4399 7E              LD   A,(HL)     ; 7 
0780   439A 7E              LD   A,(HL)     ; 7 
0781   439B 7E              LD   A,(HL)     ; 7 
0782   439C 7E              LD   A,(HL)     ; 7 
0783   439D 00              NOP
0784   439E             
0785   439E CD D8 43        call SENDNIBBLE ;151
0786   43A1             
0787   43A1 2B              DEC  HL 
0788   43A2 7E              LD   A,(HL)     ; 7 
0789   43A3 D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
0790   43A5 7E              LD   A,(HL)     ; 7 
0791   43A6 7E              LD   A,(HL)     ; 7 
0792   43A7 7E              LD   A,(HL)     ; 7 
0793   43A8 7E              LD   A,(HL)     ; 7 
0794   43A9 48              LD C,B             ;4
0795   43AA             
0796   43AA                 ; Send length in B
0797   43AA             
0798   43AA CD D8 43        call SENDNIBBLE ;151
0799   43AD             
0800   43AD 23              INC  HL         ; 6  ; DUMMY matching later dec
0801   43AE 7E              LD   A,(HL)     ; 7 
0802   43AF D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0803   43B1 7E              LD   A,(HL)     ; 7 
0804   43B2 7E              LD   A,(HL)     ; 7 
0805   43B3 7E              LD   A,(HL)     ; 7 
0806   43B4 7E              LD   A,(HL)     ; 7 
0807   43B5 00              NOP             ; 4
0808   43B6             
0809   43B6 CD D8 43        call SENDNIBBLE ;151
0810   43B9             
0811   43B9 2B              DEC  HL 
0812   43BA 7E              LD   A,(HL)     ; 7 
0813   43BB             byteloop:
0814   43BB D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
0815   43BD 7E              LD   A,(HL)     ; 7 
0816   43BE 7E              LD   A,(HL)     ; 7 
0817   43BF 7E              LD   A,(HL)     ; 7 
0818   43C0 4E              LD   C,(HL)     ; 7 
0819   43C1 00              NOP
0820   43C2 CD D8 43        call SENDNIBBLE ;151
0821   43C5 23              INC  HL         ; 6
0822   43C6 7E              LD   A,(HL)     ; 7 
0823   43C7 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0824   43C9 7E              LD   A,(HL)     ; 7 
0825   43CA 7E              LD   A,(HL)     ; 7 
0826   43CB 7E              LD   A,(HL)     ; 7 
0827   43CC 7E              LD   A,(HL)     ; 7 
0828   43CD 00              NOP
0829   43CE                                 ; 56
0830   43CE CD D8 43        CALL SENDNIBBLE ;151
0831   43D1 10 E8           DJNZ byteloop   ; 13
0832   43D3 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0833   43D5             
0834   43D5 C1              POP  BC
0835   43D6 F1              POP  AF
0836   43D7 C9              ret
0837   43D8             
0838   43D8             
0839   43D8             SENDNIBBLE: ;31 per bit, 134 incl RET 151 incl call, nibble in C lower half
0840   43D8                 ; Four bits to send
0841   43D8                 ;# bit 1 start
0842   43D8 CB 01           RLC C       ; 8
0843   43DA 38 19           JR C, csendH1 ; 12/7
0844   43DC D8              ret c        ; 11/5 dummy for symmetric timing
0845   43DD                 ;# bit 1 send 0
0846   43DD DB FE           IN      A,($FE)         ; signal to 0 /on
0847   43DF             
0848   43DF                 ;# bit 2 start
0849   43DF CB 01           RLC C       ; 8
0850   43E1 38 2A           JR C, csendH2 ; 12/7
0851   43E3 D8              ret c        ; 11/5 dummy for symmetric timing
0852   43E4                 ;# bit 2 send 0
0853   43E4 DB FE           IN      A,($FE)         ; signal to 0 /on
0854   43E6             
0855   43E6                 ;# bit 3 start
0856   43E6 CB 01           RLC C       ; 8
0857   43E8 38 34           JR C, csendH3 ; 12/7
0858   43EA D8              ret c        ; 11/5 dummy for symmetric timing
0859   43EB                 ;# bit 3 send 0
0860   43EB DB FE           IN      A,($FE)         ; signal to 0 /on
0861   43ED             
0862   43ED                 ;# bit 4 start
0863   43ED CB 01           RLC C       ; 8
0864   43EF 38 37           JR C, csendH4 ; 12/7
0865   43F1 D8              ret c        ; 11/5 dummy for symmetric timing
0866   43F2                 ;# bit 4 send 0
0867   43F2 DB FE           IN      A,($FE)         ; signal to 0 /on
0868   43F4             
0869   43F4 C9              ret
0870   43F5             
0871   43F5             
0872   43F5             csendH1:    ;# bit 1 send 1
0873   43F5 D3 FF           OUT     ($FF),A         ; signal to 1 /off
0874   43F7             
0875   43F7                 ;# bit 2 start
0876   43F7 CB 01           RLC C       ; 8
0877   43F9 38 12           JR C, csendH2 ; 12/7
0878   43FB D8              ret c        ; 11/5 dummy for symmetric timing
0879   43FC                 ;# bit 2 send 0
0880   43FC DB FE           IN      A,($FE)         ; signal to 0 /on
0881   43FE             
0882   43FE                 ;# bit 3 start
0883   43FE CB 01           RLC C       ; 8
0884   4400 38 1C           JR C, csendH3 ; 12/7
0885   4402 D8              ret c        ; 11/5 dummy for symmetric timing
0886   4403                 ;# bit 3 send 0
0887   4403 DB FE           IN      A,($FE)         ; signal to 0 /on
0888   4405             
0889   4405                 ;# bit 4 start
0890   4405 CB 01           RLC C       ; 8
0891   4407 38 1F           JR C, csendH4 ; 12/7
0892   4409 D8              ret c        ; 11/5 dummy for symmetric timing
0893   440A                 ;# bit 4 send 0
0894   440A DB FE           IN      A,($FE)         ; signal to 0 /on
0895   440C C9              ret
0896   440D             
0897   440D             csendH2:    ;# bit 2 send 1
0898   440D D3 FF           OUT     ($FF),A         ; signal to 1 /off
0899   440F             
0900   440F                 ;# bit 3 start
0901   440F CB 01           RLC C       ; 8
0902   4411 38 0B           JR C, csendH3 ; 12/7
0903   4413 D8              ret c        ; 11/5 dummy for symmetric timing
0904   4414                 ;# bit 3 send 0
0905   4414 DB FE           IN      A,($FE)         ; signal to 0 /on
0906   4416             
0907   4416                 ;# bit 4 start
0908   4416 CB 01           RLC C       ; 8
0909   4418 38 0E           JR C, csendH4 ; 12/7
0910   441A D8              ret c        ; 11/5 dummy for symmetric timing
0911   441B                 ;# bit 4 send 0
0912   441B DB FE           IN      A,($FE)         ; signal to 0 /on
0913   441D C9              ret
0914   441E             
0915   441E             csendH3:    ;# bit 3 send 1
0916   441E D3 FF           OUT     ($FF),A         ; signal to 1 /off
0917   4420             
0918   4420                 ;# bit 4 start
0919   4420 CB 01           RLC C       ; 8
0920   4422 38 04           JR C, csendH4 ; 12/7
0921   4424 D8              ret c        ; 11/5 dummy for symmetric timing
0922   4425                 ;# bit 4 send 0
0923   4425 DB FE           IN      A,($FE)         ; signal to 0 /on
0924   4427 C9              ret
0925   4428             
0926   4428             csendH4:    ;# bit 4 send 1
0927   4428 D3 FF           OUT     ($FF),A         ; signal to 1 /off
0928   442A C9              ret
0929   442B             
0930   442B             
0931   442B             
0932   442B 76             db $76   ;N/L 
0933   442C             
0934   442C             line10:
0935   442C 00 0A          db 0,10  ;line number 
0936   442E 1F 00          dw dfile-$-2  ;line length 
0937   4430 F5             db $f5   ;PRINT 
0938   4431 D4             db $d4   ;USR 
0939   4432 1D             db $1d   ;1 
0940   4433 22             db $22   ;6 
0941   4434 21             db $21   ;5 
0942   4435 1D             db $1d   ;1 
0943   4436 20             db $20   ;4 
0944   4437 7E             db $7e   ;FP mark 
0945   4438 8F             db $8f   ;5 bytes FP number 
0946   4439 01             db $01   ; 
0947   443A 04             db $04   ; 
0948   443B 00             db $00   ; 
0949   443C 00             db $00   ; 
0950   443D 1A             db $1a   ; ,
0951   443E 0B             db $0b   ; "
0952   443F 31             db c_L   ; TTTT2 = QLOAD test
0953   4440 39             db c_T   ; SNNN = dummy save for testing
0954   4441 38             db c_S   ; STST,1024,100 binsave
0955   4442 39             db c_T   ; LTST,1024   binload
0956   4443 1A             db 26
0957   4444 1D             db c_0+1   ; 
0958   4445 1C             db c_0+0   ; 
0959   4446 1E             db c_0+2   ; 
0960   4447 20             db c_0+4   ; 
0961   4448 1A             db 26
0962   4449 1D             db c_0+1   ; 
0963   444A 1C             db c_0+0   ; 
0964   444B 1C             db c_0+0   ; 
0965   444C 0B             db $0b   ; "
0966   444D 76             db $76   ;N/L 
0967   444E 76             db $76   ;N/L 
0968   444F             
0969   444F             
0970   444F                
0971   444F             ;- Display file -------------------------------------------- 
0972   444F              
0973   444F             dfile: 
0974   444F 76             db $76 
0975   4450 3F 3D          db c_Z,c_X,
0976   4452 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
0976   4456 76 76 76 76 
0977   445A 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
0977   445E 76 76 76 76 
0978   4462 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
0978   4466 76 76 76 76 
0979   446A              
0980   446A             ;- BASIC-Variables ---------------------------------------- 
0981   446A              
0982   446A             var: 
0983   446A 80             db $80 
0984   446B              
0985   446B             ;- End of program area ---------------------------- 
0986   446B             
0987   446B             last: 
0988   446B              
0989   446B                end 
tasm: Number of errors = 0
