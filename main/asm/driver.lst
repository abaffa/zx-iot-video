0001   0000             ; SYSINFO81 
0002   0000             ; 	GPL
0003   0000             ; 	Oliver Lange
0004   0000             ; 	Version 1.0.1
0005   0000             
0006   0000             ; Compile with "tasm -80 -b wspdrv.asm wspdrv.p" 
0007   0000             
0008   0000             
0009   0000             ; driver for wespi
0010   0000             ;
0011   0000             
0012   0000             
0013   0000              
0014   0000             #define db .byte ;  cross-assembler definitions 
0015   0000             #define dw .word 
0016   0000             #define ds .block 
0017   0000             #define org .org 
0018   0000             #define end .end 
0019   0000             
0020   0000             
0021   0000             
0022   0000             #define ADDR_DISABLE 0
0023   0000             #define UPDATE	01FCh	; LOAD/SAVE adress update subroutine in ROM
0024   0000             
0025   0000             ;;#define VERBOSE 1
0026   0000              
0027   4009             org     $4009 ; BASIC PROGRAMM
0028   4009             ;= System variables ============================================ 
0029   4009              
0030   4009 00             db 0     	;VERSN 
0031   400A 00 00          dw 0     	;E_PPC 
0032   400C 0F 44          dw dfile      ;D_FILE 
0033   400E 10 44          dw dfile+1    ;DF_CC 
0034   4010 2A 44          dw var   	;VARS 
0035   4012 00 00          dw 0     	;DEST 
0036   4014 2B 44          dw var+1      ;E_LINE 
0037   4016 2A 44          dw last-1     ;c_ADD 
0038   4018 00 00          dw 0     	;X_PTR 
0039   401A 2B 44          dw last  	;STKBOT 
0040   401C 2B 44          dw last  	;STKEND 
0041   401E 00             db 0     	;BERG 
0042   401F 5D 40          dw membot     ;MEM 
0043   4021 00             db 0     ;not used 
0044   4022 02             db 2     ;DF_SZ 
0045   4023 01 00          dw 1     ;S_TOP 
0046   4025 FF FF FF       db $FF,$FF,$FF     ;LAST_K 
0047   4028 37             db 55    ;MARGIN 
0048   4029 EC 43          dw line10     ;NXTLIN   line10   dfile
0049   402B 00 00          dw 0     ;OLDPPC 
0050   402D 00             db 0     ;FLAGX 
0051   402E 00 00          dw 0     ;STRLEN 
0052   4030 8D 0C          dw $0C8D      ;T_ADDR 
0053   4032 00 00          dw 0     ;SEED 
0054   4034 FF FF          dw $FFFF      ;FRAMES 
0055   4036 00 00          db 0,0   ;COORDS 
0056   4038 BC             db $BC   ;PR_CC 
0057   4039 21 18          db 33,24      ;S_POSN 
0058   403B 40             db 01000000B  ;CDFLAG 
0059   403C                ds 33    ;Print buffer --- now used for loader code, all loaded programs need to have the same !
0060   405D             
0061   405D             membot: 
0062   405D                ds 30    ;Calculator�s memory area 
0063   407B                ds 2     ;not used 
0064   407D              
0065   407D             ;= First BASIC line, asm code ================================== 
0066   407D              
0067   407D             line0: 
0068   407D 00 00          db 0,0   ;line number 
0069   407F 6B 03          dw line10-$-2 ;line length 
0070   4081 EA             db $ea   ; REM 
0071   4082             
0072   4082             
0073   4082             #define ELINE	4014h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0074   4082             #define ELINEHI	4015h  ; Systemvariable, die das Ende des abzuspeichernen BASIC-Programs anzeigt
0075   4082             
0076   4082             #define SHOW	0207h  ; ROM-Routinen
0077   4082             #define FAST	02E7h
0078   4082             #define RCLS	0A2Ah
0079   4082             #define GETKEY	02BBh
0080   4082             
0081   4082             
0082   4082             #DEFINE RST_PRTCHAR RST 10H
0083   4082             #DEFINE c_SPACE 0
0084   4082             #DEFINE c_NEWLINE 76H
0085   4082             #DEFINE c_0 1CH
0086   4082             
0087   4082             #DEFINE c_A 26H
0088   4082             #DEFINE c_B c_A+1
0089   4082             #DEFINE c_C c_A+2
0090   4082             #DEFINE c_D c_A+3
0091   4082             #DEFINE c_E c_A+4
0092   4082             #DEFINE c_F c_A+5
0093   4082             #DEFINE c_G c_A+6
0094   4082             #DEFINE c_H c_A+7
0095   4082             #DEFINE c_I c_A+8
0096   4082             #DEFINE c_J c_A+9
0097   4082             #DEFINE c_K c_J+1
0098   4082             #DEFINE c_L c_J+2
0099   4082             #DEFINE c_M c_J+3
0100   4082             #DEFINE c_N c_J+4
0101   4082             #DEFINE c_O c_J+5
0102   4082             #DEFINE c_P c_J+6
0103   4082             #DEFINE c_Q c_J+7
0104   4082             #DEFINE c_R c_J+8
0105   4082             #DEFINE c_S c_J+9
0106   4082             #DEFINE c_T c_S+1
0107   4082             #DEFINE c_U c_S+2
0108   4082             #DEFINE c_V c_S+3
0109   4082             #DEFINE c_W c_S+4
0110   4082             #DEFINE c_X c_S+5
0111   4082             #DEFINE c_Y c_S+6
0112   4082             #DEFINE c_Z c_S+7
0113   4082             
0114   4082             #define UFM_ERRNO 16434 ; Definiert in UFM, Fehlercode 1 Byte (eigentlich SEED)
0115   4082             #define UFM_CMDBUF 16444 ; Definiert in UFM, 32 Byte, alternative Kommando�bergabe (eigentlich PRBUF)
0116   4082             #define UFM_COORDS 16438 ; L�ngen�bergabe 2 Byte (eigentlich COORDS)
0117   4082             
0118   4082             
0119   4082             ;
0120   4082             ;   === Main entry point ====
0121   4082             ;
0122   4082             
0123   4082             BASIC_START:
0124   4082 CD 24 43    	CALL NAME	; get command line arg
0125   4085 18 1B       	JR BASIC_CONT
0126   4087 00          	NOP
0127   4088 00          	NOP
0128   4089 00          	NOP
0129   408A             
0130   408A             CALL_START:	; (IN UFM als START_ADDR+6 festgelegt)
0131   408A 21 3C 40    	LD HL,UFM_CMDBUF
0132   408D E5              PUSH HL
0133   408E                 ;  get length in BC by parsing for '"' or so..
0134   408E 01 00 00        LD   BC,0
0135   4091             ENDPRSLP:
0136   4091 7E              LD   A,(HL)
0137   4092 FE 0B           CP   11     ; is " ?
0138   4094 28 04           JR   Z, EXITPRSLP
0139   4096 03              INC  BC
0140   4097 23              INC  HL
0141   4098 18 F7           JR   ENDPRSLP
0142   409A             EXITPRSLP:
0143   409A E1              POP  HL ; original pointer
0144   409B CD B8 40    	CALL GENER_START
0145   409E 32 32 40    	LD (UFM_ERRNO),A
0146   40A1 C9          	RET
0147   40A2             
0148   40A2             BASIC_CONT:
0149   40A2 CD B8 40    	CALL GENER_START ; A is 0 for ok, !=0 for error
0150   40A5 A7          	AND A
0151   40A6 28 0F       	JR Z,BAS_OK
0152   40A8 3E 2A       	LD A,c_E		; Ausgabe ERR
0153   40AA D7          	RST 10h 
0154   40AB 3E 37       	LD A,c_R
0155   40AD D7          	RST 10h
0156   40AE 3E 37           LD A,c_R
0157   40B0 D7          	RST 10h
0158   40B1 3E 76           LD A,c_NEWLINE
0159   40B3 D7          	RST 10h
0160   40B4                 ; exit
0161   40B4 AF              XOR A
0162   40B5 CF          	RST 08h
0163   40B6 09              db  09h             ; Error Report: Invalid argument
0164   40B7             	;db 0FFh
0165   40B7             
0166   40B7             BAS_OK:
0167   40B7 C9          	RET  ; TODO check if RET or better RST8 with -1
0168   40B8             ;    XOR A		; sonst zurueck nach BASIC
0169   40B8             ;	RST 08h
0170   40B8             ;	db 0FFh
0171   40B8             	
0172   40B8             
0173   40B8             GENER_START: ; Interpreting the string independent of its origin, on ret A=0 for okay, BC retval to basic
0174   40B8 7E          	LD A,(HL)   ; HL=start, BC=length
0175   40B9 23              INC  HL
0176   40BA 0B              DEC  BC
0177   40BB 11 D9 40        LD   DE,GENER_END
0178   40BE D5              PUSH DE     ; ret adddess
0179   40BF             ;	CP c_I		; Info
0180   40BF             ;	JP Z,INFO1
0181   40BF FE 38       	CP c_S		; Save
0182   40C1 CA AF 41    	JP Z,SAVE1
0183   40C4 FE 31       	CP c_L		; Load
0184   40C6 CA 09 41    	JP Z,LOAD1
0185   40C9             ;	CP 29h		; ist es ein D;
0186   40C9             ;	JP Z,DIR1
0187   40C9             ;	CP 3Bh		; ist es ein V (UFM)
0188   40C9             ;	JP Z,DIRV1
0189   40C9             ;	CP 30h		; ist es ein K (UFM)
0190   40C9             ;	JP Z,DIRK1
0191   40C9             ;	CP 37h		; ist es ein R
0192   40C9             ;	JP Z,RENAM1
0193   40C9             ;	CP 2Ah		; ist es ein E
0194   40C9             ;	JP Z,ERAS1
0195   40C9 FE 39       	CP c_T		; Test, return 0...1023 dependng on number of correct bytes
0196   40CB CA 83 41    	JP Z,TESTPATTERN
0197   40CE FE 2D       	CP c_H		; Help
0198   40D0 CA 91 42    	JP Z,HLP
0199   40D3 FE 0F       	CP 0Fh		; ist es ein ?
0200   40D5 CA 91 42    	JP Z,HLP
0201   40D8 C9              ret 
0202   40D9             
0203   40D9             GENER_END:
0204   40D9 F5              PUSH AF ; holds our error status
0205   40DA C5              PUSH BC ; ret value...
0206   40DB CD 07 02    	CALL SHOW
0207   40DE C1              POP  BC
0208   40DF F1              POP  AF
0209   40E0 C9          	RET
0210   40E1             	
0211   40E1             
0212   40E1             
0213   40E1             
0214   40E1             CHECKCOMMA:  ; Z is set when comma seperator found in string, NZ if not, uses A
0215   40E1                 ; BC =0?
0216   40E1 AF              XOR  A
0217   40E2 B9              CP   C
0218   40E3 20 02           JR   NZ,CHKK_CONT
0219   40E5 3C              INC  A ; clear the Z flag
0220   40E6 C9              RET     ; no match till end
0221   40E7             CHKK_CONT:
0222   40E7 7E              LD   A, (HL)
0223   40E8 FE 1A           CP   26     ; comma
0224   40EA C8              RET  z
0225   40EB FE 1A           CP   26     ; also check for semicolon
0226   40ED C8              RET  z
0227   40EE 23              INC  HL
0228   40EF 0B              DEC  BC
0229   40F0 18 EF           JR CHECKCOMMA
0230   40F2             
0231   40F2             
0232   40F2             SKIPEMPTY:  ; Z is set when comma seperator found in string, NZ if not, uses A
0233   40F2                 ; BC =0?
0234   40F2 AF              XOR  A
0235   40F3 B9              CP   C
0236   40F4 20 05           JR   NZ,CHKE_CONT
0237   40F6 B8              CP   B
0238   40F7 20 02           JR   NZ,CHKE_CONT
0239   40F9 3C              INC  A ; clear the Z flag
0240   40FA C9              RET     ; no match till end
0241   40FB             CHKE_CONT:
0242   40FB BE              CP   (HL)
0243   40FC C0              RET  NZ ; not empty,leave
0244   40FD 23              INC  HL
0245   40FE 0B              DEC  BC
0246   40FF 18 F1           JR SKIPEMPTY
0247   4101             
0248   4101             PRINTA:
0249   4101 E5              PUSH HL
0250   4102 D5              PUSH DE
0251   4103 C5              PUSH BC
0252   4104 D7              RST 10H
0253   4105 C1              POP  BC
0254   4106 D1              POP  DE
0255   4107 E1              POP  HL
0256   4108 C9              RET
0257   4109                 
0258   4109             
0259   4109             LOAD1:
0260   4109             	; HL points to arg string, BC number of chars
0261   4109 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0262   410A C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0263   410B                 ; Check if we have contact
0264   410B 3E 31           LD   A, c_L
0265   410D CD 01 41        CALL PRINTA
0266   4110                 
0267   4110 CD BD 42        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0268   4113 A7              AND A
0269   4114                 ; Send LOAD request
0270   4114 C1              POP  BC
0271   4115 E1              POP  HL ; recover name pointer/length
0272   4116 28 2D           JR   Z, LD_ERR ; NO CONTACT after TRY_HANDSHAKE
0273   4118             
0274   4118 41              ld   B,C ; length, assume <256
0275   4119 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0276   411B CD 38 43        call SEND_PACKET
0277   411E                 ; now retrieve length, 0 for error
0278   411E CD 0A 43        CALL QLD_GETBYTE    ; uses BC D, result in A
0279   4121 6F              LD   L,A
0280   4122 06 05           LD   B,5
0281   4124 21 09 40        LD   HL,$4009
0282   4127             
0283   4127             LOADELY:         ;    //60
0284   4127 10 FE           DJNZ LOADELY
0285   4129             
0286   4129 00              NOP
0287   412A CD 0A 43        CALL QLD_GETBYTE    ; uses BC D, result in A
0288   412D 67              LD   H,A
0289   412E B5              OR   L
0290   412F 28 14           JR Z,LD_ERR
0291   4131 E5              PUSH HL             ; length, will go to BC below
0292   4132             LOADLOOP:
0293   4132                 ; timing  - 74 between calls seems to be more reliable than 70!
0294   4132 CD 0A 43        CALL QLD_GETBYTE    ; uses BC D, result in A
0295   4135 77              LD   (HL),A
0296   4136 77              LD   (HL),A ; dummy for timing
0297   4137 23              INC  HL
0298   4138 C1              POP  BC
0299   4139 0B              DEC  BC
0300   413A 79              LD   A,C
0301   413B B0              OR   B
0302   413C 28 03           JR Z, LD_END
0303   413E C5              PUSH BC
0304   413F 18 F1           JR  LOADLOOP
0305   4141             LD_END:  
0306   4141                 ; BC   0
0307   4141 AF              XOR  A
0308   4142 C9              RET ; BC WILL be at maximum now
0309   4143 CF          	RST 08h ; ALTERNATIVE
0310   4144 FF          	db 0FFh
0311   4145             LD_ERR:
0312   4145 3E 01           LD   A,1
0313   4147 C9              RET ; BC WILL be at maximum now
0314   4148             
0315   4148             
0316   4148             ; parse a decimal number
0317   4148             PARS_DEC_NUM:   ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0318   4148 11 00 00    	LD DE, 0
0319   414B AF              XOR  A
0320   414C B9              CP   C
0321   414D 28 31           JR Z,PARSFAIL
0322   414F             
0323   414F             PARS_LLOOP:     ; look for first number
0324   414F 7E          	LD A,(HL)
0325   4150 A7          	AND A
0326   4151 28 FC       	JR Z, PARS_LLOOP ; skip whitespace
0327   4153             PARS_LLP2:
0328   4153 D6 1C       	SUB 01ch	;"0"
0329   4155 DA 80 41    	JP C,PARSFAIL
0330   4158 FE 0A       	CP 10
0331   415A D2 80 41    	JP NC,PARSFAIL
0332   415D             	; have a digit in A,
0333   415D E5          	PUSH HL
0334   415E             	; DE times ten
0335   415E 62          	LD H,D      ; now in both HL and DE
0336   415F 6B          	LD L,E
0337   4160 29          	ADD HL,HL
0338   4161 29          	ADD HL,HL
0339   4162 29          	ADD HL,HL ; times 8 so far
0340   4163 19          	ADD HL,DE
0341   4164 19          	ADD HL,DE
0342   4165             	; Add new digit
0343   4165 16 00       	LD D,0
0344   4167 5F          	LD E,A
0345   4168 19          	ADD HL,DE
0346   4169 EB          	EX DE,HL    ; new value of DE
0347   416A E1          	POP HL  ; pointer to argline back in HL
0348   416B 23          	INC HL
0349   416C 0D          	DEC C
0350   416D 28 0F           JR Z,PARSDONE
0351   416F 7E          	LD A,(HL)   ; load next char to see if end
0352   4170 FE 1A           CP   26 ;  ','
0353   4172 28 0A           JR Z,PARSDONE
0354   4174 FE 0E           CP   14 ;  ';'
0355   4176 28 06           JR Z,PARSDONE
0356   4178 FE 0B           CP   11 ;  '"'
0357   417A 28 02           JR Z,PARSDONE
0358   417C 18 D5       	JR PARS_LLP2 
0359   417E             PARSDONE:
0360   417E AF              XOR  A
0361   417F C9          	RET
0362   4180             PARSFAIL:
0363   4180 AF              XOR  A
0364   4181 3C              INC  A
0365   4182 C9          	RET
0366   4183             
0367   4183             
0368   4183             TESTPATTERN:
0369   4183             	; HL points to arg string, BC number of chars
0370   4183 E5              PUSH HL  ; orig pos of args (w/o prefix T)
0371   4184 C5              PUSH BC  ; orig lenght of args (w/o prefix T)
0372   4185                 ; Check if we have contact
0373   4185             ;    LD   A, c_T
0374   4185             ;    CALL PRINTA
0375   4185                 
0376   4185 CD BD 42        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0377   4188 A7              AND A
0378   4189                 ; Send LOAD request
0379   4189 C1              POP  BC
0380   418A E1              POP  HL ; recover name pointer/length
0381   418B 28 1C           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0382   418D             
0383   418D 41              ld   B,C ; length, assume <256
0384   418E 0E 5D           ld   C,93 ; packet ID ZX_QSAVE_TAG_LOADPFILE
0385   4190 CD 38 43        call SEND_PACKET
0386   4193             
0387   4193                 ; now retrieve 1024 bytes and see how many are correct
0388   4193                 ; gap between byte calls should be 77+12+7 - 17-10 = 69 clocks
0389   4193 01 00 00        LD   BC,0
0390   4196             TESTBLOOP:
0391   4196 C5              PUSH BC
0392   4197 00              NOP         ; timing adjust 66/70
0393   4198 00              NOP         ; timing adjust 70/74 - 74 seems to be more reliable than 70!
0394   4199 CD 0A 43        CALL QLD_GETBYTE    ; uses BC D, result in A
0395   419C C1              POP  BC
0396   419D B9              CP   C  ; incomming data in A is 0,1,2,3,4...255,0,1... as byte
0397   419E 3E 00           LD   A,0 ; not affect flags, test never reports errors to better automatize
0398   41A0 C0              RET  NZ ; report BC at point of first failure
0399   41A1 03              INC  BC
0400   41A2 3E 10           LD   A,16 ; 4kbyte testsize
0401   41A4 B8              CP   B
0402   41A5 20 EF           JR   NZ, TESTBLOOP
0403   41A7 AF              XOR  A
0404   41A8 C9              RET ; BC WILL be at maximum now
0405   41A9             
0406   41A9             
0407   41A9             
0408   41A9             ERREXIT:
0409   41A9 3E 01           LD   A,1
0410   41AB 01 00 00        LD   BC,0
0411   41AE C9              RET
0412   41AF             
0413   41AF             SAVE1:
0414   41AF             	; HL points to arg string, BC number of chars
0415   41AF E5              PUSH HL  ; orig pos of args (w/o prefix S)
0416   41B0 C5              PUSH BC  ; orig lenght of args (w/o prefix S)
0417   41B1             
0418   41B1             
0419   41B1 3E 38           LD   A, c_S
0420   41B3 CD 01 41        CALL PRINTA
0421   41B6             
0422   41B6                 ; Check if we have contact
0423   41B6                
0424   41B6 CD BD 42        CALL TRY_HANDSHAKE  ; See if WESPI responds, return 1 if so, 0 for timeout
0425   41B9                 ; Send SAVE request
0426   41B9 C1              POP  BC
0427   41BA E1              POP  HL ; recover name pointer/length
0428   41BB                 ; evauate connect result
0429   41BB A7              AND A
0430   41BC 28 EB           JR   Z, ERREXIT ; NO CONTACT after TRY_HANDSHAKE
0431   41BE             
0432   41BE                 ; again store original argument string, will need it now and when sending name
0433   41BE E5              PUSH HL
0434   41BF C5              PUSH BC
0435   41C0             
0436   41C0                 ;  test if saving binary or regular basic
0437   41C0 CD E1 40        CALL CHECKCOMMA
0438   41C3 28 43           JR   Z, BINSAVE
0439   41C5             
0440   41C5                 ; SAVE BASIC program if not BINSAVE, pre-calc addr,size into HL and BC
0441   41C5 11 09 40    	LD DE,4009h		; Get length
0442   41C8 2A 14 40    	LD HL,(ELINE)	
0443   41CB A7          	AND A		; clear carry
0444   41CC ED 52       	SBC HL,DE	; HL=length
0445   41CE 44          	LD B,H
0446   41CF 4D          	LD C,L
0447   41D0 EB          	EX DE,HL	; Now HL=Start, BC=length
0448   41D1             
0449   41D1             SAVE_CONT: ;continue common path of BIN and BASIC save
0450   41D1 D9              EXX     ; store payload addr and length for now
0451   41D2 EB          	EX DE,HL	; HL' must be restored, save in DE'
0452   41D3 C1              POP  BC
0453   41D4 E1              POP  HL ; recover name pointer/length
0454   41D5 CD F2 40        CALL SKIPEMPTY 
0455   41D8 AF              XOR  A
0456   41D9 B9              CP   C
0457   41DA 28 40           JR   Z, ERREXIT3 ; NO NAME
0458   41DC 41              ld   B,C ; length, assume <256
0459   41DD 0E 5B           ld   C,91 ; packet ID ZX_QSAVE_TAG_SAVEPFILE
0460   41DF CD 38 43        call SEND_PACKET
0461   41E2 EB          	EX DE,HL	; HL' must be restored, was saved in DE'
0462   41E3 D9              EXX ; Recover, now HL=Start, BC=length
0463   41E4             	
0464   41E4             SVSENDFUL:
0465   41E4 AF              XOR  A
0466   41E5 B8              CP   B
0467   41E6 28 0C           JR   Z, SVSENDLAST
0468   41E8                 ; send full packets
0469   41E8 C5              PUSH BC
0470   41E9 06 00           LD   B,0    ; 256 bytes
0471   41EB 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0472   41ED CD 38 43        call SEND_PACKET
0473   41F0 C1              POP  BC
0474   41F1 05              DEC  B
0475   41F2 18 F0           JR   SVSENDFUL
0476   41F4             
0477   41F4             SVSENDLAST:
0478   41F4 AF              XOR  A
0479   41F5 B9              CP   C
0480   41F6 28 06           JR   Z, SVSENDEND
0481   41F8 41              LD   B,C ; length
0482   41F9 0E 5F           LD   C,95 ; packet ID ZX_QSAVE_TAG_DATA
0483   41FB CD 38 43        call SEND_PACKET
0484   41FE             
0485   41FE             SVSENDEND:
0486   41FE CD F0 42        CALL QS_FINAL_ACK   ; Z set for success
0487   4201 20 A6           JR   NZ, ERREXIT
0488   4203 AF              XOR  A
0489   4204 01 01 00        LD   BC, 1
0490   4207 C9          	RET
0491   4208             
0492   4208             
0493   4208             BINSAVE: ; HL points to the comma in arg string, now parse addr, length
0494   4208 23              INC  HL
0495   4209 0D              DEC  C
0496   420A CD 48 41        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0497   420D 20 13           JR NZ, BSERREXIT   ; parse error
0498   420F D5              PUSH DE ; store addr, from now on have to use BSERREXIT2 to stack-unwind here
0499   4210 23              INC  HL
0500   4211 0D              DEC  C
0501   4212 CD 48 41        CALL PARS_DEC_NUM ; HL points to char in arg line, C holds remaining ARG size, return dec in DE, uses AF, Z set when okay
0502   4215 20 0A           JR NZ, BSERREXIT2   ; parse error
0503   4217                 ; length in DE
0504   4217                 ; Now put HL=Start, BC=length
0505   4217 42              LD   B,D
0506   4218 4B              LD   C,E
0507   4219 E1              POP  HL
0508   421A 18 B5           JR SAVE_CONT
0509   421C             
0510   421C             ERREXIT3:
0511   421C EB          	EX DE,HL	; HL' must be restored, saved in DE'
0512   421D D9              EXX ; Recover
0513   421E 3E 01           LD   A,1
0514   4220 C9          	RET
0515   4221             
0516   4221             BSERREXIT2:
0517   4221 D1              POP  DE
0518   4222             BSERREXIT:
0519   4222 C1              POP  BC
0520   4223 E1              POP  HL ; recover name pointer/length
0521   4224 3E 01           LD   A,1
0522   4226 C9          	RET
0523   4227             
0524   4227             
0525   4227             HLPTXT:
0526   4227 3F 3D 00 3C 	db c_Z,c_X,0,c_W,c_E,c_S,c_P,c_I,0,c_D,c_R,c_I,c_V,c_E,c_R,0, c_0,27,c_0+1,c_0,c_0,c_NEWLINE
0526   422B 2A 38 35 2E 
0526   422F 00 29 37 2E 
0526   4233 3B 2A 37 00 
0526   4237 1C 1B 1D 1C 
0526   423B 1C 76 
0527   423D 76              db c_NEWLINE
0528   423E             ;	db "INFO  ",22h,"I",22h,0dh
0529   423E             ;	db "DIR   ",22h,"D",22h,0dh
0530   423E             ;	db "ERASE ",22h,"ENAME.P",22h,0dh
0531   423E             ;	db "MKDIR ",22h,"DMVERZ",22h,0dh
0532   423E             ;	db "RMDIR ",22h,"DEVERZ",22h,0dh
0533   423E             ;	db "CHDIR ",22h,"DCVERZ",22h,0dh
0534   423E 31 34 26 29 	db c_L,c_O,c_A,c_D, 0 , 0 , 0, 11, c_L, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "LOAD  ",22h,"LNAME.P",22h,0dh
0534   4242 00 00 00 0B 
0534   4246 31 33 26 32 
0534   424A 2A 0B 76 
0535   424D             ;	db "BLOAD ",22h,"LNAME.B,SSSS",22h,0dh
0536   424D 38 26 3B 2A 	db c_S,c_A,c_V,c_E, 0 , 0 , 0, 11, c_S, c_N, c_A, c_M, c_E, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0536   4251 00 00 00 0B 
0536   4255 38 33 26 32 
0536   4259 2A 0B 76 
0537   425C 27 38 26 3B 	db c_B,c_S,c_A,c_V,c_E, 0 , 0, 11, c_S, c_N, c_A, c_M, c_E,26, c_A, c_D, c_D, c_R, 26, c_L, c_E, c_N,  11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0537   4260 2A 00 00 0B 
0537   4264 38 33 26 32 
0537   4268 2A 1A 26 29 
0537   426C 29 37 1A 31 
0537   4270 2A 33 0B 76 
0538   4274             ;	db "BSAVE ",22h,"SNAME.B,SSSS,EEEE",22h,0dh
0539   4274             ;	db "RENAME",22h,"ROLDNAME NEWNAME",22h,0dh
0540   4274 39 2A 38 39 	db c_T,c_E,c_S,c_T, 0 , 0 , 0, 11, c_T, c_L, c_T, c_T, c_T, c_0+2, 11,c_NEWLINE   ; "SAVE  ",22h,"SNAME.P",22h,0dh
0540   4278 00 00 00 0B 
0540   427C 39 31 39 39 
0540   4280 39 1E 0B 76 
0541   4284 2D 2A 31 35 	db c_H,c_E,c_L,c_P, 0 , 0 , 0, 11, c_H, 11,c_NEWLINE   ;  c_H,   "HELP  ",22h,"H",22h,0dh
0541   4288 00 00 00 0B 
0541   428C 2D 0B 76 
0542   428F             ;	db "FOR SIGGI'S UFM :V/R/K",0dh
0543   428F 76              db c_NEWLINE
0544   4290 FF          	db $ff
0545   4291             
0546   4291             
0547   4291             ; === Subroutine print help text ====
0548   4291             
0549   4291 21 27 42    HLP:	LD HL,HLPTXT
0550   4294 7E          HLP1:	LD A,(HL)
0551   4295 FE FF       	CP $FF
0552   4297 28 04       	JR Z, EXITHLP
0553   4299 D7              RST 10H
0554   429A 23          	INC HL
0555   429B 18 F7       	JR HLP1
0556   429D             EXITHLP:
0557   429D 01 2A 00        LD   BC,42
0558   42A0 AF              XOR  A
0559   42A1 C9              RET
0560   42A2             
0561   42A2             
0562   42A2             
0563   42A2             GO_QSAVE_MODE:
0564   42A2 CD E7 02    	CALL FAST	; go to fast mode
0565   42A5 DB FE           IN      A,($FE)         ; signal to 0 pause    
0566   42A7 06 C8           LD B,200  ; 200=200ms Pause
0567   42A9 C5          W1: push BC
0568   42AA 06 00           ld b,0
0569   42AC             W2:
0570   42AC 10 FE           djnz W2     ; 1 millisec (256*4)
0571   42AE C1              pop BC
0572   42AF 10 F8           djnz W1
0573   42B1 1E 4B           LD E, 75    ; ID for ZX_SAVE_TAG_QSAVE_START
0574   42B3 CD 1F 03        call $031F  ; SAVE byte in E
0575   42B6 D3 FF           OUT     ($FF),A         ; ; signal to 1 / syncoff, send hsyncs
0576   42B8 06 00           ld b,0
0577   42BA             W4:
0578   42BA 10 FE           djnz W4     ; 1 millisec (256*4) to go to QSAVE mode
0579   42BC C9              RET
0580   42BD             
0581   42BD             TRY_HANDSHAKE:  ; See if WESPI responds, return 1 if so, 0 for timeout
0582   42BD CD A2 42        CALL GO_QSAVE_MODE
0583   42C0 21 04 40        ld   hl, 16388 ; RAMTOP
0584   42C3 06 02           ld   B,2
0585   42C5 0E 5A           ld   C,90 ; packet ID ZX_QSAVE_TAG_HANDSHAKE
0586   42C7 CD 38 43        call SEND_PACKET
0587   42CA 06 B5           ld   b,181  ; timeout, 500ms (inner loop 3.15ms)
0588   42CC             HS_LOOP1:
0589   42CC C5              PUSH BC
0590   42CD 06 00           LD   B,0
0591   42CF             HS_LOOP2:                  ; 35 cycles=10.7us, inner Loop 2.75 millisec
0592   42CF DB FE           in a,($FE)  ; 11
0593   42D1 17              rla         ; 4
0594   42D2 38 0E           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0595   42D4 10 F9           DJNZ HS_LOOP2 ;13
0596   42D6                 ; re-check here to not have a blind spot for outer loop
0597   42D6 DB FE           in a,($FE)  ; 11
0598   42D8 17              rla         ; 4
0599   42D9 38 07           jr c,HS_FOUND ; 12 / 7  (D7=0 is low level, wait for high)
0600   42DB C1              POP  BC
0601   42DC 10 EE           DJNZ HS_LOOP1
0602   42DE D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff
0603   42E0                 ; no signal found
0604   42E0 AF              XOR  A
0605   42E1 C9              RET
0606   42E2             
0607   42E2             HS_FOUND
0608   42E2 D3 FF           OUT     ($FF),A  ; signal to 1 / syncoff
0609   42E4                 ; let the output recover with active signal after being low from input. takes about 1ms as seen in oscilloscope
0610   42E4 06 00           LD   B,0
0611   42E6             HS_FINALDELAY: ; 2ms here
0612   42E6 7E              LD   A,(HL)
0613   42E7 7E              LD   A,(HL)
0614   42E8 10 FC           DJNZ HS_FINALDELAY
0615   42EA C1              POP  BC
0616   42EB 3E 01           LD   A,1
0617   42ED A7              AND  A
0618   42EE C9              RET
0619   42EF             
0620   42EF             QS_FINAL_SZ:
0621   42EF 00              db 0 ; size of return packet to request, use smallest possible
0622   42F0             
0623   42F0             QS_FINAL_ACK:  ; Get info is operation was sussessful (Z) or failed (NZ), USES BC DE HL, A
0624   42F0 21 EF 42        ld   hl, QS_FINAL_SZ ; Requested length
0625   42F3 06 01           ld   B,1
0626   42F5 0E 63           LD   C,99 ; packet ID ZX_QSAVE_TAG_END_RQ
0627   42F7 CD 38 43        call SEND_PACKET
0628   42FA             
0629   42FA                 ; await reply, first byte is tag, then result
0630   42FA CD 0A 43        CALL QLD_GETBYTE
0631   42FD FE 2A           CP   42 ; tag
0632   42FF C0              RET  NZ
0633   4300 06 08           ld B,8  ; 
0634   4302             QSFDLY:
0635   4302 10 0F           djnz lgapdly     ; 13*n-5 = 47 for 4
0636   4304 CD 0A 43        CALL QLD_GETBYTE
0637   4307 FE 01           CP   1 ; result
0638   4309 C9              RET    ; Z on match
0639   430A             
0640   430A             
0641   430A             
0642   430A             ; gab between byte calls should be 77+12+7 - 17-10 = 69 clocks
0643   430A             
0644   430A             QLD_GETBYTE:    ; uses BC D, result in A
0645   430A 0E FE           ld c,$fe   ; 7
0646   430C 06 08           ld b,8  ; 7    for gap between start and bits
0647   430E             
0648   430E             lwt_stdly:                  ; 25 cycles=7.7us
0649   430E DB FE           in a,($FE)  ; 11
0650   4310 17              rla         ; 4
0651   4311 30 FB           jr nc,lwt_stdly ; 12 / 7  (D7=0 is low level, wait for high)
0652   4313                 ; trigger is seen 4us too late in average, so wait 48-4 - 4 us now: 130 cy in-in
0653   4313             lgapdly:
0654   4313 10 FE           djnz lgapdly     ; 13*n-5 = 99 for 8
0655   4315 06 08           ld b,8  ; 7
0656   4317             lbloop:                 ;  need 104 for 32us
0657   4317 ED 50           in d,(c)    ; 12
0658   4319 CB 12           rl d        ; 8
0659   431B 17              rla         ; 4 (rl a is 8)
0660   431C 16 04           ld d,4      ; 7
0661   431E             lbdly:
0662   431E 15              dec d          ; 4          b*16-5 = 59
0663   431F 20 FD           jr nz,lbdly     ; 12 / 7
0664   4321 10 F4           djnz lbloop     ; 13 / 8
0665   4323 C9              RET     
0666   4324                 
0667   4324                 ;ORIGINAL:
0668   4324                 ;ld (hl),a   ; 7
0669   4324             	;CALL UPDATE  ; will use DE, inc HL    77 clks
0670   4324                 ;jr lwt_start     ; 12
0671   4324             
0672   4324             
0673   4324             
0674   4324             
0675   4324             ;*
0676   4324             ;* Evaluate string  start of the string is in HL and the length in BC
0677   4324             ;*
0678   4324 E7          NAME:	RST 20h
0679   4325 CD 55 0F    	CALL 0F55h ; evaluate
0680   4328 3A 01 40    	LD A,(4001h)
0681   432B 87          	ADD A,A
0682   432C FA 9A 0D    	JP M,0D9Ah  ; error
0683   432F E1          	POP HL
0684   4330 D0          	RET NC
0685   4331 E5          	PUSH HL
0686   4332 CD F8 13    	CALL 13F8h ; get indexvar fom calc stack STK-FETCH
0687   4335                 ; For strings, the start of the string is in DE and the length in BC
0688   4335 62          	LD H,D
0689   4336 6B          	LD L,E
0690   4337 C9          	RET
0691   4338             
0692   4338             
0693   4338             SEND_PACKET: ; HL points to data, C holds type, B lenght (0=256bytes), HL will point behind sent data afterwards
0694   4338 F5              PUSH AF
0695   4339 C5              PUSH BC ; BC needed twice, for header, and recovered at end
0696   433A C5              PUSH BC
0697   433B             
0698   433B 06 E1           LD B,225    ;   TODO 125 should be enough
0699   433D             SPWT:
0700   433D 10 FE           djnz SPWT     ; 500 microsec  (125*4)  ; let the video lines sync again, require 5 lines (320), some margin added
0701   433F             
0702   433F                 ; we want all our pulses in sync with the HSYNC pulses to not interfere   
0703   433F AF              XOR A       ; make sure A' not at sync or display position to
0704   4340 08              EX AF,AF'   ; just cause short INT on MNI here:
0705   4341                             
0706   4341 D3 FE           OUT ($FE),A  ; ENABLE NMI
0707   4343 76              HALT
0708   4344 D3 FD           OUT ($FD),A  ; Disable NMI   from here, start first bit in 54us =174cy
0709   4346 DB FE           IN      A,($FE)         ; signal to 0 /on - syncout
0710   4348 7E              LD   A,(HL)     ; 7 dummy 
0711   4349 00              NOP             ; 4
0712   434A 06 07           LD   B,7
0713   434C 00              NOP             ; timing adjust to have bits symmetrical in (black-shouldered) line
0714   434D D3 FF           OUT     ($FF),A ;11        ; signal to 1 / syncoff
0715   434F             waitnline:
0716   434F 10 FE           DJNZ waitnline          ; delay for next line 13 per loop ..
0717   4351 C1              POP  BC            ;10
0718   4352             
0719   4352             
0720   4352                 ; Send packettype in C
0721   4352             
0722   4352 CD 98 43        call SENDNIBBLE ;151, so we need 56 cycles between nibbles to get to 207 for one hsync line
0723   4355             
0724   4355 23              INC  HL         ; 6  ; DUMMY matching later dec
0725   4356 7E              LD   A,(HL)     ; 7 
0726   4357 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0727   4359 7E              LD   A,(HL)     ; 7 
0728   435A 7E              LD   A,(HL)     ; 7 
0729   435B 7E              LD   A,(HL)     ; 7 
0730   435C 7E              LD   A,(HL)     ; 7 
0731   435D 00              NOP
0732   435E             
0733   435E CD 98 43        call SENDNIBBLE ;151
0734   4361             
0735   4361 2B              DEC  HL 
0736   4362 7E              LD   A,(HL)     ; 7 
0737   4363 D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
0738   4365 7E              LD   A,(HL)     ; 7 
0739   4366 7E              LD   A,(HL)     ; 7 
0740   4367 7E              LD   A,(HL)     ; 7 
0741   4368 7E              LD   A,(HL)     ; 7 
0742   4369 48              LD C,B             ;4
0743   436A             
0744   436A                 ; Send length in B
0745   436A             
0746   436A CD 98 43        call SENDNIBBLE ;151
0747   436D             
0748   436D 23              INC  HL         ; 6  ; DUMMY matching later dec
0749   436E 7E              LD   A,(HL)     ; 7 
0750   436F D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0751   4371 7E              LD   A,(HL)     ; 7 
0752   4372 7E              LD   A,(HL)     ; 7 
0753   4373 7E              LD   A,(HL)     ; 7 
0754   4374 7E              LD   A,(HL)     ; 7 
0755   4375 00              NOP             ; 4
0756   4376             
0757   4376 CD 98 43        call SENDNIBBLE ;151
0758   4379             
0759   4379 2B              DEC  HL 
0760   437A 7E              LD   A,(HL)     ; 7 
0761   437B             byteloop:
0762   437B D3 FF           OUT     ($FF),A ;11        ; signal to 1 /off
0763   437D 7E              LD   A,(HL)     ; 7 
0764   437E 7E              LD   A,(HL)     ; 7 
0765   437F 7E              LD   A,(HL)     ; 7 
0766   4380 4E              LD   C,(HL)     ; 7 
0767   4381 00              NOP
0768   4382 CD 98 43        call SENDNIBBLE ;151
0769   4385 23              INC  HL         ; 6
0770   4386 7E              LD   A,(HL)     ; 7 
0771   4387 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0772   4389 7E              LD   A,(HL)     ; 7 
0773   438A 7E              LD   A,(HL)     ; 7 
0774   438B 7E              LD   A,(HL)     ; 7 
0775   438C 7E              LD   A,(HL)     ; 7 
0776   438D 00              NOP
0777   438E                                 ; 56
0778   438E CD 98 43        CALL SENDNIBBLE ;151
0779   4391 10 E8           DJNZ byteloop   ; 13
0780   4393 D3 FF           OUT     ($FF),A ; 11        ; signal to 1 /off
0781   4395             
0782   4395 C1              POP  BC
0783   4396 F1              POP  AF
0784   4397 C9              ret
0785   4398             
0786   4398             
0787   4398             SENDNIBBLE: ;31 per bit, 134 incl RET 151 incl call, nibble in C lower half
0788   4398                 ; Four bits to send
0789   4398                 ;# bit 1 start
0790   4398 CB 01           RLC C       ; 8
0791   439A 38 19           JR C, csendH1 ; 12/7
0792   439C D8              ret c        ; 11/5 dummy for symmetric timing
0793   439D                 ;# bit 1 send 0
0794   439D DB FE           IN      A,($FE)         ; signal to 0 /on
0795   439F             
0796   439F                 ;# bit 2 start
0797   439F CB 01           RLC C       ; 8
0798   43A1 38 2A           JR C, csendH2 ; 12/7
0799   43A3 D8              ret c        ; 11/5 dummy for symmetric timing
0800   43A4                 ;# bit 2 send 0
0801   43A4 DB FE           IN      A,($FE)         ; signal to 0 /on
0802   43A6             
0803   43A6                 ;# bit 3 start
0804   43A6 CB 01           RLC C       ; 8
0805   43A8 38 34           JR C, csendH3 ; 12/7
0806   43AA D8              ret c        ; 11/5 dummy for symmetric timing
0807   43AB                 ;# bit 3 send 0
0808   43AB DB FE           IN      A,($FE)         ; signal to 0 /on
0809   43AD             
0810   43AD                 ;# bit 4 start
0811   43AD CB 01           RLC C       ; 8
0812   43AF 38 37           JR C, csendH4 ; 12/7
0813   43B1 D8              ret c        ; 11/5 dummy for symmetric timing
0814   43B2                 ;# bit 4 send 0
0815   43B2 DB FE           IN      A,($FE)         ; signal to 0 /on
0816   43B4             
0817   43B4 C9              ret
0818   43B5             
0819   43B5             
0820   43B5             csendH1:    ;# bit 1 send 1
0821   43B5 D3 FF           OUT     ($FF),A         ; signal to 1 /off
0822   43B7             
0823   43B7                 ;# bit 2 start
0824   43B7 CB 01           RLC C       ; 8
0825   43B9 38 12           JR C, csendH2 ; 12/7
0826   43BB D8              ret c        ; 11/5 dummy for symmetric timing
0827   43BC                 ;# bit 2 send 0
0828   43BC DB FE           IN      A,($FE)         ; signal to 0 /on
0829   43BE             
0830   43BE                 ;# bit 3 start
0831   43BE CB 01           RLC C       ; 8
0832   43C0 38 1C           JR C, csendH3 ; 12/7
0833   43C2 D8              ret c        ; 11/5 dummy for symmetric timing
0834   43C3                 ;# bit 3 send 0
0835   43C3 DB FE           IN      A,($FE)         ; signal to 0 /on
0836   43C5             
0837   43C5                 ;# bit 4 start
0838   43C5 CB 01           RLC C       ; 8
0839   43C7 38 1F           JR C, csendH4 ; 12/7
0840   43C9 D8              ret c        ; 11/5 dummy for symmetric timing
0841   43CA                 ;# bit 4 send 0
0842   43CA DB FE           IN      A,($FE)         ; signal to 0 /on
0843   43CC C9              ret
0844   43CD             
0845   43CD             csendH2:    ;# bit 2 send 1
0846   43CD D3 FF           OUT     ($FF),A         ; signal to 1 /off
0847   43CF             
0848   43CF                 ;# bit 3 start
0849   43CF CB 01           RLC C       ; 8
0850   43D1 38 0B           JR C, csendH3 ; 12/7
0851   43D3 D8              ret c        ; 11/5 dummy for symmetric timing
0852   43D4                 ;# bit 3 send 0
0853   43D4 DB FE           IN      A,($FE)         ; signal to 0 /on
0854   43D6             
0855   43D6                 ;# bit 4 start
0856   43D6 CB 01           RLC C       ; 8
0857   43D8 38 0E           JR C, csendH4 ; 12/7
0858   43DA D8              ret c        ; 11/5 dummy for symmetric timing
0859   43DB                 ;# bit 4 send 0
0860   43DB DB FE           IN      A,($FE)         ; signal to 0 /on
0861   43DD C9              ret
0862   43DE             
0863   43DE             csendH3:    ;# bit 3 send 1
0864   43DE D3 FF           OUT     ($FF),A         ; signal to 1 /off
0865   43E0             
0866   43E0                 ;# bit 4 start
0867   43E0 CB 01           RLC C       ; 8
0868   43E2 38 04           JR C, csendH4 ; 12/7
0869   43E4 D8              ret c        ; 11/5 dummy for symmetric timing
0870   43E5                 ;# bit 4 send 0
0871   43E5 DB FE           IN      A,($FE)         ; signal to 0 /on
0872   43E7 C9              ret
0873   43E8             
0874   43E8             csendH4:    ;# bit 4 send 1
0875   43E8 D3 FF           OUT     ($FF),A         ; signal to 1 /off
0876   43EA C9              ret
0877   43EB             
0878   43EB             
0879   43EB             
0880   43EB 76             db $76   ;N/L 
0881   43EC             
0882   43EC             line10:
0883   43EC 00 0A          db 0,10  ;line number 
0884   43EE 1F 00          dw dfile-$-2  ;line length 
0885   43F0 F5             db $f5   ;PRINT 
0886   43F1 D4             db $d4   ;USR 
0887   43F2 1D             db $1d   ;1 
0888   43F3 22             db $22   ;6 
0889   43F4 21             db $21   ;5 
0890   43F5 1D             db $1d   ;1 
0891   43F6 20             db $20   ;4 
0892   43F7 7E             db $7e   ;FP mark 
0893   43F8 8F             db $8f   ;5 bytes FP number 
0894   43F9 01             db $01   ; 
0895   43FA 04             db $04   ; 
0896   43FB 00             db $00   ; 
0897   43FC 00             db $00   ; 
0898   43FD 1A             db $1a   ; ,
0899   43FE 0B             db $0b   ; "
0900   43FF 38             db c_S   ; TTTT2 = QLOAD test
0901   4400 39             db c_T   ; SNNN = dummy save for testing
0902   4401 38             db c_S   ; STST,1024,100 binsave
0903   4402 39             db c_T   ; 
0904   4403 1A             db 26
0905   4404 1D             db c_0+1   ; 
0906   4405 1C             db c_0+0   ; 
0907   4406 1E             db c_0+2   ; 
0908   4407 20             db c_0+4   ; 
0909   4408 1A             db 26
0910   4409 1D             db c_0+1   ; 
0911   440A 1C             db c_0+0   ; 
0912   440B 1C             db c_0+0   ; 
0913   440C 0B             db $0b   ; "
0914   440D 76             db $76   ;N/L 
0915   440E 76             db $76   ;N/L 
0916   440F             
0917   440F             
0918   440F                
0919   440F             ;- Display file -------------------------------------------- 
0920   440F              
0921   440F             dfile: 
0922   440F 76             db $76 
0923   4410 3F 3D          db c_Z,c_X,
0924   4412 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
0924   4416 76 76 76 76 
0925   441A 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
0925   441E 76 76 76 76 
0926   4422 76 76 76 76    db $76,$76,$76,$76,$76,$76,$76,$76 
0926   4426 76 76 76 76 
0927   442A              
0928   442A             ;- BASIC-Variables ---------------------------------------- 
0929   442A              
0930   442A             var: 
0931   442A 80             db $80 
0932   442B              
0933   442B             ;- End of program area ---------------------------- 
0934   442B             
0935   442B             last: 
0936   442B              
0937   442B                end 
tasm: Number of errors = 0
